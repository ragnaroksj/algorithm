
Reverse String:
function FirstReverse(str) { 
  var s = '';
  for(var i = str.length - 1; i >= 0; i--){
    s += str[i];
  }
  return s;
}
--------------------------------------


Input = "fun&!! time"Output = "time"
Input = "I love dogs"Output = "love" 
求最长字
function LongestWord(sen) { 
  var senArray = sen.replace(/[^A-Za-z1-9 ]/g,"").split(" ");
  var maxWord ="";
  for(var i = 0; i < senArray.length; i++){
    if( senArray[i].length > maxWord.length ) {
      maxWord = senArray[i];
    }
  }
  // code goes here  
  return maxWord;        
}
-------------------------------------

Using the JavaScript language, have the function LetterChanges(str) take the str parameter being passed and modify it using the following algorithm. Replace every letter in the string with the letter following it in the alphabet (ie. c becomes d, z becomes a). Then capitalize every vowel in this new string (a, e, i, o, u) and finally return this modified string. 
function LetterChanges(str) { 
  var char = 0, modStr = "", strCode = 0;
  str = str.toLowerCase();
  for(var i = 0; i < str.length; i++){
    char = str.charCodeAt(i);
    if( char < 97  || char > 122 ) strCode = char;
    else if( char == 122 ) strCode = 65;
    else if( char == 100 ) strCode = 69;
    else if( char == 104 ) strCode = 73;
    else if( char == 110 ) strCode = 79;
    else if( char == 116 ) strCode = 85;
    else strCode = ++char;
    modStr += String.fromCharCode(strCode);
  }
  // code goes here  
  return modStr;         
}
--------------------------------------------------------------------

阶加
function SimpleAdding(num) { 
  
  // code goes here  
  return ( num == 0 ) ? num : (num + SimpleAdding(num-1)); 
  //or
  return (num+1)*num/2;       
}
--------------------------------------------------------------------
Capitalize:
Input = "hello world" Output = "Hello World"
Input = "i ran there"Output = "I Ran There" 
function LetterCapitalize(str) { 
  var flag = 1;
  var strArray = str.split("");
  
  for( var i = 0; i < strArray.length; i++ ){
    if( flag == 1) {
      strArray[i] = strArray[i].toUpperCase();
      flag = 0;
    }else if( strArray[i] == " ") flag = 1;
  }
 
  // code goes here  
  return strArray.join(""); 
         
}
---------------------------------------------------------------------


Using the JavaScript language, have the function SimpleSymbols(str) take the str parameter being passed and determine if it is an acceptable sequence by either returning the string true or false. The str parameter will be composed of + and = symbols with several letters between them (ie. ++d+===+c++==a) and for the string to be true each letter must be surrounded by a + symbol. So the string to the left would be false. The string will not be empty and will have at least one letter. function SimpleSymbols(str) { 
function SimpleSymbols(str) { 
  for(var i = 0 ; i<str.length; i++){
    if(/^[A-Za-z]*$/.test(str[i])) {
      if(i == 0 || (i==str.length-1) || str[i-1] != "+" || str[i+1] != "+"){ 
        return false;
      }
    }
  }
  // code goes here  
  return true; 
        
}
------------------------------------------------------------------------
比大小
function CheckNums(num1,num2) {
  try{
    if(!isNum(num1, num2)) throw "input must be integer";
    if( num1 - num2 > 0) return "false";
    else if( num1 - num2 < 0 ) return "true";
    else return "-1";
  }catch(err){
    return err;
  }
}
function isNum(num1, num2){
  return !(isNaN(parseInt(num1))  || isNaN(parseInt(num2)));
}

or 
//no detecting
function CheckNums(num1,num2) { 
  return num1 == num2 ? "-1" : ( num1 < num2);       
}
-----------------------------------------------------------------

分钟转换成小时分钟
function TimeConvert(num) { 
  return Math.floor(num/60) + ":" + ( num%60 );
}
-----------------------------------------------------------------

排序
function AlphabetSoup(str) { 
  var strArray = str.split("");
  strArray = bubble(strArray);
  str = strArray.join("");
 
  // code goes here  
  return str;         
}

function bubble(array){
  var temp;
  for (var i = 0; i < array.length; i++) {
    for (var j = array.length-1; j > 0; j--) {
      
      if ( (array[j].toLowerCase()) < array[j - 1].toLowerCase()) {
        var temp = array[j - 1];
        array[j - 1] = array[j];
        array[j] = temp;
      }
    }
  }
  return array;
}

or
return str.split("").sort().join(""); 
----------------------------------------------------------------------

窗口查找 ab
function ABCheck(str) { 
  var strArray = str.split("");
  var windowArray =["","","","",""];
  for(var i =0 ; i< (strArray.length - windowArray.length +1) ; i++){
    for(var j =0 ; j<windowArray.length; j++){
      windowArray[j] = strArray[j+i];
    }
    if((windowArray[0] == "a" && windowArray[windowArray.length-1] == "b") || (windowArray[0] == "b" && windowArray[windowArray.length-1] == "a")){
      return true;
    }
  }
  // code goes here  
  return false; 
 
 or

 function ABCheck(str) { 

  // code goes here  
  return /(a...b)|(b...a)/.test(str); 
         
}
-----------------------------------------------------------------------

function VowelCount(str) { 
  var strArray = str.split("");
  var vowel ={"a" : 0, "e" : 0, "i" : 0, "o" : 0, "u": 0};
  var sum =0;
  for(var i=0; i< strArray.length; i++){
    if(vowel[strArray[i].toLowerCase()] != undefined){
      vowel[(strArray[i].toLowerCase())] +=1;
    }
  }
  
  for(var i in vowel){
     sum += vowel[i]; 
  }
  // code goes here  
  return sum; 
         
}

or
 var arr=str.match(/[aeiou]/gi);
  if (arr) return arr.length;
  return 0; 
or
function VowelCount(str) {
  var count = 0;
  for( var i = 0; i < str.length; i++){
    if( str[i] == "a" 
       || str[i] == "e"
       || str[i] == "i"
       || str[i] =="o"
       || str[i] == "u"){
      count++;
    }
  }
  // code goes here  
  return count; 
         
}

-------------------------------------------------------------------

function WordCount(str) { 

  // code goes here  
  return (str == "" || str == " ") ? 0 : str.split(" ").length; 
         
}

----------------------------------------------------------------------
xoox true , xox false
function ExOh(str) {
  var flag = 0;
  for( var i  = 0; i < str.length; i++){
    ( str[i] == "x" ) ? flag++ : flag--;
  }
 
  // code goes here  
  return !flag; 
         
}

------------------------------------------------------------------------

function Palindrome(str) { 
  str = str.replace(/[^A-Za-z]/g,"");
  for( var i = 0; i < Math.floor(str.length/2); i++){
    if( str[i] != str[str.length-1-i] ) return false;
  }
  // code goes here  
  return true; 
         
}
-------------------------------------------------------------------------

function ArithGeo(arr) { 
  return is(arr, "Geometric") || is(arr, "Arithmetic") || -1;
}
function is(arr,type){
  if(arr.length < 2) return 0;
  var constant =  (type == "Geometric") ? arr[1]/arr[0] : (arr[1]-arr[0]);
  for(var i = 2 ; i < arr.length ; i++){
    if( type == "Geometric" && (arr[i]/arr[i-1] != constant) ){
      return 0;
    }else if(type == "Arithmetic" && ( (arr[i]-arr[i-1]) != constant) ){
      return 0;
    }
  }
  return type;
}
-------------------------------------------------------------------------
Greatest alphbet in word
function LetterCountI(str) { 
  var strArray = str.split(" ");
  var maxWord = "", maxValue = 1;
  var subStrArray = [];
  
  for( var i = 0; i < strArray.length; i++){
    subStrArray = [];
    for( var j = 0; j< strArray[i].length; j++){
      if(subStrArray[strArray[i][j]] == undefined) subStrArray[strArray[i][j]] = 1;  
      else subStrArray[strArray[i][j]]++ ;
      if(subStrArray[strArray[i][j]] > maxValue) {
        maxValue = subStrArray[strArray[i][j]];
        maxWord = strArray[i];
      }
    }
  }
  // code goes here  
  return maxWord || -1; 

or 

function LetterCountI(str) { 
  var strArray = str.split(" ");
  var strstr = [];
  var maxValue = 0;
  var maxWord = "";
  for(var i = 0; i< strArray.length; i++){
    if(checkLetter(strArray[i]) > maxValue){
      maxValue = checkLetter(strArray[i]);
      maxWord = strArray[i];
    }
  }
  
  if(maxValue == 1) return -1;
  // code goes here  
  return maxWord; 
         
}

function checkLetter(str){
  var strArray = str.split("");
  var strstr = [];
  var max = 0;
  for(var i = 0; i < strArray.length; i++){
    if(strstr[strArray[i]] == undefined) strstr[strArray[i]]=1;
    else {
      strstr[strArray[i]] +=1 ;
    }
    
    if(strstr[strArray[i]] > max){
      max = strstr[strArray[i]];
    }
  }
  return max;
}


-------------------------------------------------------------------------------

secondgreatlow 第二大
function SecondGreatLow(arr) { 
  var arr = sort(arr);
  if(arr.length == 2) return arr[1]+" "+arr[0];
  return getSecond(arr,"smin")+" "+getSecond(arr,"smax");
}
function getSecond(arr,type){
  for(var i = 1 ; i<arr.length; i++){
    if(arr[i] != arr[i-1] && type == "smin") return arr[i];
    if(arr[arr.length-i-1] != arr[arr.length-i] && type=="smax") return arr[arr.length-i-1];
  }
}
function sort(arr){
  for(var i = 0; i < arr.length; i++){
    for(var j = arr.length-1; j>0 ; j--){
      if(arr[j] < arr[j-1]){
          var temp = arr[j];
          arr[j] = arr[j-1];
          arr[j-1] = temp;
      }
    }
  }
  return arr;
}

-----------------------------------------------------------------------------


function MeanMode(arr) { 
  if( mean(arr) == mode(arr) ) return 1 ;
  else return 0;
  // code goes here  
}

function mean(arr){
  var sum = 0;
  for( var i = 0 ; i < arr.length; i++){
    sum += arr[i];
  }
  return sum/arr.length;
}

function mode(arr){
  var modeValue = 0;
  var modeArray = [];
  var maxMode = 0;
  for( var i = 0 ; i < arr.length; i++){
    if( modeArray[arr[i]] == undefined) modeArray[arr[i]] = 1;
    else modeArray[arr[i]]++;
    if( modeArray[arr[i]] > maxMode ){
      maxMode = modeArray[arr[i]];
      modeValue = arr[i];
    }
  }
  return modeValue;
}

----------------------------------------------------------------------------------
123456789/10 = 12,345,678
function DivisionStringified(num1,num2) { 
  var result = Math.round(num1/num2).toString();
  var resultArray = result.split("");
  var j = 0;
  var length = resultArray.length
  for( var i = 1; i < length/3 ; i++ ){
    resultArray.splice((-3*i-j),0,",");
    j++;
  }
  return resultArray.join("");       
}

-------------------------------------------------------------------------------

if str is 9:00am-10:00am then the output should be 60. If str is 1:00pm-11:00am the output should be 1320. 
function CountingMinutesI(str) { 
  var timeArray = str.split("-");
  for(var i = 0 ; i < timeArray.length; i++){
    timeArray[i] = formatPMTime(timeArray[i]);
  }
  var hourVal = 60*(timeArray[1]["hour"] - timeArray[0]["hour"]);
  var minVal = timeArray[1]["min"] - timeArray[0]["min"];
  var result = hourVal + minVal;
  if( result >= 0) return result;
  if( result < 0 ) return (result+1440); 
  // code goes here  
  return str; 
         
}
function formatPMTime(timeVal){
  var isPM = timeVal.indexOf("pm");
  var timeUnit = [];
  var timeUnitArray = timeVal.split(":");
  var timeUnitAdd = (isPM != -1) ? 12 : 0; 
  timeUnit["hour"] = parseInt(timeUnitArray[0]) + timeUnitAdd; 
  timeUnit["min"] = parseInt(timeUnitArray[1]);
  return timeUnit;
}

-----------------------------------------------------------------------------------------
34433223  => 3443-3223 奇数插入－
function DashInsert(num) { 
  var numArray = num.toString().split("");
  var j = 0;
  for( var i = 0; (i+j) < (numArray.length-1); i++){
    if( numArray[i+j]%2 != 0 && numArray[i+1+j]%2 !=0 ){
      numArray.splice((i+j+1),0,"-");
      j++;
    }
  }
  return numArray.join("");
 
}


-----------------------------------------------------------------------------------------
大小写交换
function SwapCase(str) { 
  var strArray = str.split("");
  var aCode = "a".charCodeAt(0);
  var zCode = "z".charCodeAt(0);
  var ACode = "A".charCodeAt(0);
  var ZCode = "Z".charCodeAt(0);
  for( var i = 0 ; i < strArray.length; i++ ){
    if( strArray[i].charCodeAt(0) >= aCode && strArray[i].charCodeAt(0) <= zCode  ){
      strArray[i] = strArray[i].toUpperCase();
    }else if( strArray[i].charCodeAt(0) >= ACode && strArray[i].charCodeAt(0) <= ZCode){
      strArray[i] = strArray[i].toLowerCase();
    }
  }
  return strArray.join("");
}

or

function SwapCase(str) {

  // code goes here
  var arr = str.split('');
  arr = arr.map(function(c) {
    if (c >= 'a' && c <= 'z') return c.toUpperCase();
    else return c.toLowerCase();
  });
  return arr.join('');

}

-----------------------------------------------------------------------------------------

function NumberAddition(str) { 
  var sum = 0;
  var j = 0;
  for( var i = 0; (i+j) <= str.length; i+=j ){
    j = 0; 
    var num = 0;
    while( !isNaN(parseInt(str[j+i])) ){
      num += str[j+i].toString();
      j++;
    }
    sum += parseInt(num);
    j = (j == 0) ? 1 : j;
  }
  // code goes here  
  return sum;       
}
   
or

function NumberAddition(str) { 

  // code goes here 
  var ans=str.match(/[0-9]+/g);
  var total = 0;
  if(ans != null) { for (i=0;i<ans.length;i++) { total+=ans[i]*1 } }
  return total; 
         
}

or

function NumberAddition(str) {
  return str.split(/[^\d]+/g).reduce(function(p, n){return p + (+n);}, 0);
}

----------------------------------------------------------------------------------



function ThirdGreatest(strArr) { 
  var strArray = [];
  for( var i = 0; i < strArr.length; i++){
    if( strArray[strArr[i].length.toString()] == undefined ) strArray[strArr[i].length.toString()] = [];
    strArray[strArr[i].length.toString()].push(strArr[i]);
  }
  var j = 3;
  for( var i = strArray.length-1 ; i>=0; i--){
     if( strArray[i] == undefined) continue;
    if( strArray[i.toString()].length >= j) return strArray[i.toString()].pop();
    else j -= strArray[i.toString()].length;
  }
  // code goes here  
  return strArr; 
                
}

or

function ThirdGreatest(strArr) { 
  strArr.sort(function(a,b){
    return b.length - a.length;
  });      
  return strArr[2];
}


数组任意n个值相加是否等于数组最大值
i>>j&1： 101 表示最后循环拿数组中第一位和第三位的值相加

function ArrayAdditionI(arr) { 

  // code goes here  
  arr.sort(function(a,b){return b-a;});
  var max = arr.shift();
  for (var i = 0; i < Math.pow(2, arr.length); i++) {
    var sum = 0;
    for (var j = 0; j < arr.length; j++) {
      if (i >> j & 1) sum += arr[j];
    }
    if (sum == max) return true;
  }
  return false; 
         
}

-----------------------------------------------------------------

数字回文
function panlindarNum(num){
  if(num < 0) return false;
  if(num < 10) return true;

  var rev=0;
  while(num != 0){
    rev = rev*10 + num%10;
    num = Math.floor(num/10);
  }
  if(rev == num) return true;
  return false;
}

---------------------------------------------------------------------------

function PrimeTime(num) { 
  if( num == 1 || num == 2) return true;
  for(var i = 3 ; i < num ; i++){
    if( num % i == 0) return false;
  }
  return true;         
}

Improvement:

    step-1: Any number will not be divisible by a number bigger than half of it. for example, 13 will never be divisible by 7, 8, 9 .. it could be as big as half of it for even number. for example, 16 will be divisible by 8 but will never be by 9, 10, 11, 12...
    Decision: a number will never be divisible by a number bigger than half of its values. So, we dont have to loop 50%
    step-2: Now, if a number is not divisible by 3. (if it is divisible by 3, then it wouldn't be a prime number). then it would be divisible any number bigger than the 1/3 of its value. for example, 35 is not divisible by 3. hence it will be never divisible by any number bigger than 35/3 will never be divisible by 12, 13, 14 ... if you take an even number like 36 it will never be divisible by 13, 14, 15
    Decision: a number could be divisible by numbers 1/3 of its value.
    step-3: For example u have the number 127. 127 is not divisible by 2 hence you should check upto 63.5. Secondly, 127 is not divisible by 3. So, you will check up to 127/3 approximately 42. It is not divisible by 5, divisor should be less than 127/5 approximately 25 not by 7. So, where should we stop?
    Decision: divisor would be less than Math.sqrt (n)

Improvement:
function PrimeTimeII(num){

  for( var i = 3 ; i < Math.sqrt(num) ; i++){
    if( num % i == 0) return false;
  }
  return true;
}

---------------------------------------------------------------------------
9->23
function PrimeMover(num) {
  var count = 0, isNotPrime = 0;
  for( var i = 2 ; i < 10000; i++){
    isNotPrime = 0;
    for( var j = i-1 ; j > 1 ; j--){
      if( i%j == 0 ) {
        isNotPrime = 1;
        break;
      }
    }
    if( isNotPrime == 0 ) count++;
    if( count == num ) return i;
  }
  // code goes here  
  return false; 
         
}

--------------------------------------------------------------------------
Prime factor
function PrimeFactor(num){
  var primeFactor = [];
  for( i = 2; i <=num; ){
    if( num%i == 0) {
      primeFactor.push(i);
      num = num/i;
    }else{
      i++;
    }
  }
  return primeFactor;
}


--------------------------------------------------------------------------
function fibonacci(n){
  var fibo = [0,1];
  if( n == 1 ) return fibo[0];
  if( n == 2 ) return fibo[1];
  for( var i = 2; i < n; i++){
    fibo[i] = fibo[i-1]+fibo[i-2];
  }
  return fibo[i];
}

What is the run time complexity? O(n)

Recursive version:
function fibonacciR(n){
  if( i <= 2) return i;
  return fibonacciR(n-1)+fibonacciR(n-2);
}


--------------------------------------------------------------------------
aabbccdea => 2a2b2c1d1e1a
function RunLength(str) { 
  var preStr = str[0], flag = 1, newStr = "";
  for(var i = 1; i <= str.length; i++){
    if( str[i] == preStr ) flag++;
    else{
       newStr += flag + str[i-1];
       flag = 1;
       preStr = str[i];
    }
  }
  // code goes here  
  return newStr;         
}



----------------------------------------------------------------------------------

function PalindromeTwo(str) { 
  str = str.replace(/[^A-Za-z]/g,"");
  str = str.toLowerCase();
  for(var i = 0; i < Math.floor(str.length/2); i++ ){
    if( str[i] != str[str.length-1-i] ) return false;
  }
  // code goes here  
  return true; 
         
}

---------------------------------------------------------------------------------------
最大公约数
function Division(num1,num2) { 
  var num = num1 <= num2 ? num1 : num2;
  var Bnum =  num1 <= num2 ? num2 : num1;
  for( var i = num  ; i > 1; i--){
    if( num%i == 0 && Bnum%i == 0) return i; 
  }
  return 1;
}

---------------------------------------------------------------------------------------


function StringScramble(str1,str2) { 
  if( str2.length > str1.length ) return false;
  var str = [];
  var flag = 0;
  for( var i = 0 ; i < str1.length; i++){
    if( str[str1[i]] == undefined ) str[str1[i]] = 1;
    else str[str1[i]]++;
    
    if( i < str2.length ){
      if( str[str2[i]] == undefined ) str[str2[i]] = -1;
      else str[str2[i]]--;
    }
    
    if( str[str1[i]] < 0) flag--;
      else if( flag < 0 ) flag++;

    
  }
  return ( flag < 0 ? false : true )
}

------------------------------------------------------------------------------------------

function StringScramble(str1,str2) { 
  if( str2.length > str1.length ) return false;
  var str = [];
  for( var i = 0 ; i < str1.length; i++){
    if( str[str1[i].toString()] == undefined ) str[str1[i].toString()] = 1;
    else str[str1[i].toString()]++;
    
    if( i < str2.length ){
      if( str[str2[i].toString()] == undefined ) {
        str[str2[i].toString()] = -1;
      }else {
        str[str2[i].toString()]--;
      }
    }
  }
  
  for(var i in str){
    if( str[i] < 0 ) return false;
  }

   return true;
}

---------------------------------------------------------------------------------------------

var flag = 1;
function AdditivePersistence(num) { 

  // code goes here
  if( num < 10) return 0;
  var sum = 0;
  num = num.toString();
  for( var i = 0; i < num.length; i++){
    sum += parseInt(num[i]);
  }
  
  if( sum < 10 ){
    return flag;
  }else{
    flag++;
    AdditivePersistence(sum);  
  }
  return flag;
}
                           
function AdditivePersistence(num) { 

  var count = 0;
  while (num>9) {
    var newNum = 0;
    var digits = num.toString().split("");
    for (var i = 0; i < digits.length; i++) {
      newNum += parseInt(digits[i]);
    }
    num = newNum;
    count++;
  }
  return count; 
         
}

-----------------------------------------------------------------------------
balance or unbalance parenthesis

var str = "{ [ ( { } ) ] { }";
parenthesis(str);


function parenthesis(strInput){

  var strArray = strInput.split(" ");
  var frontArray = [];
  for(var i = 0; i < strArray.length; i++){
    if( strArray[i] === "{" || strArray[i] === "[" || strArray[i] === "(") {
      frontArray.push(strArray[i]);      
    }
    else if( strArray[i] === "}" && frontArray.pop() !== "{" ){
      return false;
    }
    else if( strArray[i] === "]" && frontArray.pop() !== "["){
      return false;
    }
    else if( strArray[i] === ")" && frontArray.pop() !== "(" ){
      return false;
    }
  }
  
  if( frontArray.length !== 0) return false;
  return true;
}

-----------------------------------------------------------------------------
permute
var permArr = [],
  usedChars = [];

function permute(input) {
  var i, ch;
  for (i = 0; i < input.length; i++) {
    ch = input.splice(i, 1)[0];
    usedChars.push(ch);
    if (input.length == 0) {
      permArr.push(usedChars.slice());
    }
    permute(input);
    input.splice(i, 0, ch);
    usedChars.pop();
  }
  return permArr
};


-----------------------------------------------------------------------------

Given a string, find whether it has any permutation of another string. For example, given "abcdefg" and "ba", it shuold return true, because "abcdefg" has substring "ab", which is a permutation of "ba".
function detect(p,d){
  var flag = true;
  var perArray = permute(p.split(""));
  perArray.forEach(function(element,index){
     var e = element.join("");
     var reg = new RegExp(e);
    flag = !reg.test(d) ? false : true;
  });
  return flag;
}


var permArr = [],
  usedChars = [];

function permute(input) {
  var i, ch;
  for (i = 0; i < input.length; i++) {
    ch = input.splice(i, 1)[0];
    usedChars.push(ch);
    if (input.length == 0) {
      permArr.push(usedChars.slice());
    }
    permute(input);
    input.splice(i, 0, ch);
    usedChars.pop();
  }
  return permArr
};


detect("ba","acbcdf");


-----------------------------------------------------------------------------                           
                            
find substring

function substring(a,b){
  for(var i=0; i<a.length; i++){
    for(var j=0;j<b.length; j++){
      if( b[j] !== a[i+j]) break;
      else if( j === b.length-1) return true;
    }
  }
  return false;
}


substring("cabcd","abc")                     

O(n)
function substring(a,b){
  var flag = 1;
  
  for(var i=1; i<=a.length; i++){
    if( a[i-1] !== b[flag-1] ){
      flag = 1;
    }else if( flag === b.length ){
       return true;
    }else{
      flag++;
    }
  }
  return false;
}

-------------------------------------------------------------------------------

substring("cavbcd","abc")

Given a string, find the longest possible even palindrome (length of palindrome is even) from it. 
Eg: 
Input: abcicbbcdefggfed 
Output: defggfed (length is 8) 

Available palindromes are 
1) bcicb - has odd length 
2) cbbc - even length 
3) defggfed - longest palindrome with even length 


function lp(s){
  var maxLength = 0, maxP="";
  for(var i = 0; i < s.length; i++){
    for( var j = s.length-1; j>=0; j--){
      if( i >= j) break;
      if( s[i] === s[j] && (j-i+1)%2==0 ){
        var sT = s.split("").slice(i,j+1).join("");        
        if( p(sT) ){
          if( sT.length > maxLength ){
            maxLength = sT.length;
            maxP = sT;
          }
        }
      }
    }
  }
  if( !maxLength ) return false;
  else return maxP;
}

function p(s){
  for( var i = 0; i < s.length/2; i++){
    if( s[i] !== s[s.length-1-i] ) return false;
  }
  return true;
}

lp("abcicbbcdefggfed");

--------------------------------------------------------------------

//mergeSort
var a = [34, 203, 3, 746, 200, 984, 198, 764, 9];

function mergeSort(arr){
  if( arr.length < 2 ) return arr;
  var mid = parseInt(arr.length/2);
  var leftArray = arr.slice(0,mid);
  var rightArray = arr.slice(mid,arr.length);
  return merge(mergeSort(leftArray), mergeSort(rightArray));
}

function merge(left,right){
  var result = [];
  
  while( left.length && right.length ){
    if( left[0] <= right[0] ){
      result.push( left.shift() );
    }else{
      result.push( right.shift() );
    }
  }
  
  while( left.length ){
    result.push( left.shift() );
  }
  
  while( right.length ){
    result.push( right.shift() );
  }
  
  return result;
}

console.log(mergeSort(a));

---------------------------------------------------------------------

bubble sort
var a = [45,1,10,43,23,6,4]

function bubble(arr){
  var swap;
  do{
    swap = false;
    for(var i = 0; i < arr.length-1; i++){
      if( arr[i] > arr[i+1]){
        var tmp = arr[i];
        arr[i] = arr[i+1];
        arr[i+1] = tmp;
        swap = true;
      }
    }
  }while(swap);
  
  return arr;
}

console.log(bubble(a));

-----------------------------------------------------------------------

insert sort

function insertSort(arr){
	for( var i = 1; i < arr.length; i++ ){
		var element = arr[i];
		var j = i;
		while( j > 0 && arr[j-1] > element){
			arr[j] = arr[j-1];
			j = j-1;
			arr[j] = element;
		}
	}
	return arr;
}

-----------------------------------------------------------------------

selection sort

function selectionSort(arr){
	for( var i = 0; i < arr.length; i++){
		var min = i;
		for( var j = i+1 ; j < arr.length; j++){
			if( arr[min] > arr[j] ){
				min = j;
			}
		}
		if( min != i ){
			var temp = arr[i]
			arr[i] = arr[min];
			arr[min] = temp;
		}
	}
}

-----------------------------------------------------------------------
radix sort

var a = [1,9,6,3,6,8,3,5,2]

function radix(arr){
  var a = {};
  var b = [];
  for( var i = 0, arrLength = arr.length; i < arrLength; i++){
    if( a[arr[i]] === undefined) a[arr[i]] = 1;
    else a[arr[i]] += 1;
  }
  
  for( var i in a){
    if( a[i] ===1 ){
      b.push(parseInt(i));
    }else{
      while(a[i]-- >0){
        b.push(parseInt(i));
      }
    }
  }
  return b;
}


console.log(radix(a));

-----------------------------------------------------------------------

quickSort

function quickSort(a, left, right){
	if( left > right) return;
	var i = left;
	var j = right;
	var key = a[left];

	while( i < j ){
		while( i < j && key < a[j]) j--;
		a[i] = a[j];
		while( i < j && key > a[i]) i++;
		a[j] = a[i];
	}

	a[i] = key;
	quickSort(a, left, i-1);
	quickSort(a, i+1, right);
	return a;
}


function quickSort(arr){
  console.log(arr);
  
  if(arr.length <=1) return arr;
  var pivot = arr[arr.length-1];
  var storeIndex = 0;
  
  for(var i = 0; i < arr.length-1; i++){
    if( arr[i] <= pivot){
      var temp = arr[i];
      arr[i] = arr[storeIndex];
      arr[storeIndex] = temp;
      storeIndex++;
    }
  }
  
  temp = arr[storeIndex];
  arr[storeIndex] = arr[arr.length-1];
  arr[arr.length-1] = temp;
  
  //console.log(storeIndex);
  
  if( storeIndex === arr.length-1) return arr;
  else return quickSort(arr.slice(0,storeIndex)).concat( quickSort(arr.slice(storeIndex,arr.length))); 
}

console.log(quickSort([3,4,5,1,9,2,7,3]));

-----------------------------------------------------------------------

//idle after 15s and away after 30s
jQuery(function(){
  console.log("begin");
  var idle = 0;
  
  jQuery("body").on("keypress mousemove",function(){
    idle = 0;
  });
  
  setInterval(function(){
    console.log(idle);
    idle += 1;
    if( idle > 2){
     console.log("idle");
    }
    if( idle > 5){
      console.log("away");
    }
    
  }, 5000);
  
});

----------------------------------------------------------------------------

function cal(str){
  var reg = /\([0-9+\s]*\)/g;
  var newStr = str.replace(reg,function(match){
    var addResult = 0;
    var mulResult = 1;
    var uI = match.split(" ");
    if( uI[1] === "+" ){
      for( var j = 2; j < uI.length-1; j++){
        addResult += parseInt(uI[j]); 
      }
      return addResult;
    }else{
      for( var j = 1; j < uI.length-1; j++){
        mulResult *= parseInt(uI[j]);
      }
      return mulResult;
    }   
    
  });
  
  if( isNaN(parseInt(newStr)) ){
    return cal(newStr);
  }else return newStr;
  
}

function format(str){
  return cal("( "+str+" )");
}

console.log(format("( + 7 (  8 12 ) (  2 (+ 9 4) 7 ) 3 )"));

-----------------------------------------------------------------

function infixPostfix(str){
  var operatorStack = [], postfixString = "", currentSymbol = "", strArray = [];
  strArray = str.split("");
  while( strArray.length ){
    currentSymbol = strArray.shift() ;
    //console.log( /[A-Za-z]/.test(currentSymbol) );
    if( /[A-Za-z]/.test(currentSymbol) ) postfixString += currentSymbol;
    else{
      if( !operatorStack.length || operatorStack[operatorStack.length-1] === "(" ){
        operatorStack.push(currentSymbol);
      }else if( currentSymbol === "(" ){
        operatorStack.push(currentSymbol);
      }else if( currentSymbol === ")" ){
        while( operatorStack[operatorStack.length-1] !== "(" ){
          postfixString += operatorStack.pop();
        }
        operatorStack.pop();
      }else if( operatorStack.length && /[+-]/.test(currentSymbol) && /[+-]/.test(operatorStack[operatorStack.length-1]) ){
          postfixString += operatorStack.pop();
          operatorStack.push(currentSymbol);
      }else {
        while( operatorStack.length && /[+-]/.test(currentSymbol) && !(/[+-]/.test(operatorStack[operatorStack.length-1])) ){
          postfixString += operatorStack.pop();
        }
        operatorStack.push(currentSymbol);
      }
    }
  }
  
  while( operatorStack.length ){
    postfixString += operatorStack.pop();
  }
  
  return postfixString;
}

infixPostfix("a*b+c");

A summary of the rules follows:

1. Print operands as they arrive.

2. If the stack is empty or contains a left parenthesis on top, push the incoming operator onto the stack.

3. If the incoming symbol is a left parenthesis, push it on the stack.

4. If the incoming symbol is a right parenthesis, pop the stack and print the operators until you see a left parenthesis. Discard the pair of parentheses.

5. If the incoming symbol has higher precedence than the top of the stack, push it on the stack.

6. If the incoming symbol has equal precedence with the top of the stack, use association. If the association is left to right, pop and print the top of the stack and then push the incoming operator. If the association is right to left, push the incoming operator.

7. If the incoming symbol has lower precedence than the symbol on the top of the stack, pop the stack and print the top operator. Then test the incoming operator against the new top of stack.

8. At the end of the expression, pop and print all operators on the stack. (No parentheses should remain.)

--------------------------------------------------------------------------

var pre = [];

function perm(a,k,n){
  if( k === n ) {
    pre.push(a.slice());
  }
  else{
    for(var i = k; i < n ; i++){
      var t = a[k];
      a[k] = a[i];
      a[i] = t;
      perm(a,k+1,n);
      t = a[k];
      a[k] = a[i];
      a[i] = t;
    }
  }
}

var arr = [1,2,3];
perm(arr,0,3);

console.log(pre);

-----------------------------------------------
Binary tree search





function binarytree(){
  this.Nodes = new Array();
  this.level = 0;
  this.node = 0;
}

binarytree.prototype = {
  
  getLocation : function(level, node){
      return node + (1 << level ) - 1;
  },
  
  getNode : function(level, node){
    if( level === undefined){
      return this.Nodes[this.getLocation(this.level, this.node)];
    }else{
      return this.Nodes[this.getLocation(level,node)];
    }
  },
  
  setNode : function(value, level, node){
    if( level === undefined ){
      return this.Nodes[this.getLocation(this.level, this.node)] = value;
    }else{
      return this.Nodes[this.getLocation(level, node)] = value;
    }
  },
  
  leftChild : function(value){
    this.level++;
    this.node = this.node*2;
    if( value !== undefined ){
      this.Nodes[this.getLocation(this.level, this.node)] = value;
    }else{
      return this.Nodes[this.getLocation(this.level, this.node)];
    }
  },
  
  rightChild : function(value){
    this.level++;
    this.node = this.node*2+1;
    if( value !== undefined ){
      this.Nodes[this.getLocation(this.level, this.node)] = value;
    }else{
      return this.Nodes[this.getLocation(this.level, this.node)];
    }
  },
  
  parentOperate: function(value){
    this.level--;
    this.node = this.node >> 1;
    if( value !== undefined ){
     this.Nodes[this.getLocation(this.level,this.node)] = value;
    }else{
      return this.Nodes[this.getLocation(this.level, this.node)];
    }
  },
  
  root: function(value){
    this.level = 0;
    this.node = 0;
    if( value !== undefined){
      this.Nodes[this.getLocation(this.level, this.node)] = value;
    }else{
      return this.Nodes[this.getLocation(this.level, this.node)];
    }
  },

  //depth-first
  dft: function(){
    console.log(this.getNode());
    if( this.leftChild() !== undefined ) this.dft();
    this.parentOperate();
    if( this.rightChild() !== undefined ) this.dft();
    this.parentOperate();
  },

  inOrder: function(){
    if( this.leftChild() !== undefined ) this.inOrder();
    this.parentOperate();
    console.log(this.getNode());
    if( this.rightChild() !== undefined ) this.inOrder();
    this.parentOperate();
  },

  postOrder: function(){
    if( this.leftChild() !== undefined ) this.postOrder();
    this.parentOperate();
    if( this.rightChild() !== undefined ) this.postOrder();
    this.parentOperate();
    console.log(this.getNode());
  }
}


var bt = new binarytree();
bt.setNode(1,0,0);
bt.setNode(2,1,0);
bt.setNode(3,1,1);
bt.setNode(4,2,0);
bt.setNode(5,2,1);
bt.setNode(6,2,2);
bt.setNode(7,2,3);
console.log(bt.dft());

}


Breadth-first search:
function printTree(tree){
 
    var queue = [];
 
    // enqueue root
    queue.push( 0 );
 
    do {
 
        var len = queue.length;
 
        // for each node in the queue
        for( var i = 0; i < len; i++ ){
             
            // dequeue
            var index = queue.shift();
 
            // print node
            document.writeln( index );
 
            var node = tree[ index ];
 
            // enqueue children of the node
            if( node.left ) {
                queue.push( node.left );
            }
            if( node.right ) {
                queue.push( node.right );
            }      
 
        }
         
        // print a line break
        document.writeln("<br>");
     
    // repeat
    } while( 0 !== queue.length );
     
}
 
// run it
printTree(T);

-------------------------------------

—————————————leetcode——————————————————
2sum
/**
* @param {number[]} nums
* @param {number} target
* @return {number[]}
*/
var twoSum = function(nums, target) {
var hash = [];
var result = [];

for( var i = 0; i < nums.length; i++){
if( hash[nums[i]] !== undefined ){
result[0] = hash[nums[i]]+1;
result[1] = i + 1;
}else{
hash[target-nums[i]] = i;
}
}
return result;
};


3sum
思路： 先排序然后检测，注意重复数字
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

    Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
    The solution set must not contain duplicate triplets.

    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    if( !nums.length ) return [];
    var number = [], i = 0;
    var flag = 0;
    
    nums.sort( function(a,b){
        return a-b;
    });
    
    for( var z = 0; z < nums.length; z++ ){
        var l = z + 1;
        var r = nums.length - 1;
        
        if( z > 0){
            if( nums[z] === nums[z-1] ) continue;
        } 
       
        while( l < r ){
            
            if( l > z + 1 ) {
                if( nums[l] === nums[l-1] ) {
                    l++;
                    continue;
                }
            }
            
            if( r < nums.length-1 ){
                if( nums[r] === nums[r+1] ) {
                    r--;
                    continue;
                }
            }
            
            if( nums[z] + nums[l] + nums[r] === 0 ){
                number[i] = [];
                number[i].push( nums[z] );
                number[i].push( nums[l] );
                number[i].push( nums[r] );
                i++;
                if(flag){
                	l++;
                }else r--;
            }else if( nums[z] + nums[l] + nums[r] < 0){
                l++;
                flag = 1;
            }else{
                r--;
                flag = 0;
            }
        }
    }
    
    return number;
};

3sum closest
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
    if( !nums.length ) return [];
    
    nums.sort( function(a,b){
        return a-b;
    });
    
    var number = 0;
    var diff = Math.abs(target - (nums[0] + nums[1] + nums[2]));
    var closetN = 0;
    
    for( var z = 0; z < nums.length; z++ ){
        var l = z + 1;
        var r = nums.length - 1;
        
        while( l < r ){
           
            number = nums[z] + nums[l] + nums[r];
            if( Math.abs(target - number ) <= diff ) {
                diff = Math.abs(target - number );
                closetN = number;
            }
            if( number < target ) l++;
            else if( number > target) r--;
            else return target;
        }
    }
    
    return closetN;
};

4sum

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    if( !nums.length ) return [];
    
    nums.sort( function(a,b){
        return a-b;
    });
    
    var number = [], i = 0;
    var flag = 0;
    
    for(a = 0; a < nums.length; a++){
        
        if( a > 0 ){
            if( nums[a] === nums[a-1]) continue;
        }

        for( var b = a+1; b < nums.length; b++ ){
            var l = b + 1;
            var r = nums.length - 1;
       
            if( b > a+1 ){
                if( nums[b] === nums[b-1] ) continue;
            } 
       
            while( l < r ){
            
                if( l > b+ 1 ) {
                    if( nums[l] === nums[l-1] ) {
                        l++;
                        continue;
                    }
                }
            
                if( r < nums.length-1 ){
                    if( nums[r] === nums[r+1] ) {
                        r--;
                        continue;
                    }
                }
            
                if( nums[a] + nums[b] + nums[l] + nums[r] === target ){
                    number[i] = [];
                    number[i].push( nums[a] );
                    number[i].push( nums[b] );
                    number[i].push( nums[l] );
                    number[i].push( nums[r] );
                    i++;
                    if(flag){
                    	l++;
                    }else r--;
                }else if( nums[a] + nums[b] + nums[l] + nums[r] < target){
                    l++;
                    flag = 1;
                }else{
                    r--;
                    flag = 0;
                }
            }
        }
    }
    
    return number;
};

reverse an integer
/**
* @param {number} x
* @return {number}
*/
var reverse = function(x) {
if( x === 0) return 0;
var rev = 0, y = Math.abs(x);
while( y !== 0 ){
if( rev > 214748364) return 0;
rev = rev*10 + y%10;
y = Math.floor(y/10);
}

return x > 0 ? rev : -rev;
};




integer is a palindrome
/**
* @param {number} x
* @return {boolean}
*/
var isPalindrome = function(x) {
if( x < 0 ) return false;
var y = x, rev = 0;
while( y !== 0){
rev = rev*10 + y%10;
y = Math.floor(y/10);
}
return rev === x ? true : false;
};


Valid Parentheses
/**
* @param {string} s
* @return {boolean}
*/
var isValid = function(s) {
var stack = [];
for( var i = 0; i < s.length; i++){
if( s[i] === "(" || s[i] === "{" || s[i] === "[" ){
stack.push(s[i]);
}else if( s[i] === ")" && stack.pop() !== "(" ){
return false;
}else if( s[i] === "}" && stack.pop() !== "{" ){
return false;
}else if( s[i] === "]" && stack.pop() !== "[" ){
return false;
}
}

return !stack.length;
};



zigzag:
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".
/**
* @param {string} s
* @param {number} numRows
* @return {string}
*/
var convert = function(s, numRows) {
if( numRows === 1) return s;
var result = [];
var basicStep = 2*numRows-2;
var step = 0;
for( var i = 0; i < numRows; i++ ){
if( i !== 0 && i !== numRows-1 ){
step = basicStep - 2* i;
}else{
step = basicStep;
}
var j = i;
var flag = 0;
while( j <= s.length ){
result.push(s[j]);
if( i === 0 || i === numRows-1 || !flag ){
j += step;
}else{
j += (basicStep - step) ;
}
flag = !flag;
}
}
return result.join("");
};


Play nim heap:take 1,2,3, give n and decide whether you can win
var canWinNim = function(n) {
return (n%4 === 0) ? false : true;
};


addDitigs 28-> 1

var addDigits = function(num) {
if( num < 10 ) return num;
var numArray = num.toString().split("");
var result = 0;
for( var i = 0; i < numArray.length; i++){
result += parseInt(numArray[i]);
}
if( result < 10 ) return result;
return addDigits( result );
};


求2x树最大深度
/**
* Definition for a binary tree node.
* function TreeNode(val) {
* this.val = val;
* this.left = this.right = null;
* }
*/
/**
* @param {TreeNode} root
* @return {number}
*/
var maxDepth = function(root) {
if( root === null ) return 0;
return Math.max(maxDepth(root.left)+1, maxDepth(root.right)+1);
};


remove Element:
给定一个数移除数组中该数返回新长度
/**
* @param {number[]} nums
* @param {number} val
* @return {number}
*/
var removeElement = function(nums, val) {
var j = nums.length, i = 0;
while( i < j ){
if( nums[i] === val ){
nums[i] = nums[j-1];
nums[j-1] = val;
nums.pop();
j--;
}else{
i++;
}
}

return j;
};

—————————————————-
remove Nth Node From End of List
/**
* Definition for singly-linked list.
* function ListNode(val) {
* this.val = val;
* this.next = null;
* }
*/
/**
* @param {ListNode} head
* @param {number} n
* @return {ListNode}
*/
var removeNthFromEnd = function(head, n) {
if( n === 0 || !head ) return null;
var current = head;
var cache = [];
var i = 0;

while( current ){
cache[i] = current;
current = current.next;
i++;
}

var removeIndex = cache.length - n;

if( !cache[removeIndex -1] ){
return cache[1] || [] ;
}else if( !cache[removeIndex+1] ){
cache[removeIndex-1].next = null;
return cache[0];
}else{
cache[removeIndex-1].next = cache[removeIndex+1];
return cache[0];
}

};

Implement srtStr()
/**
* @param {string} haystack
* @param {string} needle
* @return {number}
*/
var strStr = function(haystack, needle) {
return haystack.indexOf(needle);
};

Majority number:出现次数>n/2
/**
* @param {number[]} nums
* @return {number}
*/
var majorityElement = function(nums) {
var hash = [];
for( var i = 0; i < nums.length; i++ ){
if( hash[nums[i]] === undefined ) hash[nums[i]] = 1;
else hash[nums[i]] += 1;

if( hash[nums[i]] > Math.floor(nums.length/2) ) return nums[i];
}

};

Delete Node in a Linked List
/**
* Definition for singly-linked list.
* function ListNode(val) {
* this.val = val;
* this.next = null;
* }
*/
/**
* @param {ListNode} node
* @return {void} Do not return anything, modify node in-place instead.
*/
var deleteNode = function(node) {
var tmp = node.next;
node.val = node.next.val;
node.next = node.next.next;
};
same tree
/**
* Definition for a binary tree node.
* function TreeNode(val) {
* this.val = val;
* this.left = this.right = null;
* }
*/
/**
* @param {TreeNode} p
* @param {TreeNode} q
* @return {boolean}
*/
var isSameTree = function(p, q) {
if( !p && !q ) return true;
else if( (p && !q) || (!p && q) ) return false;
else{
if( p.val !== q.val ){
return false;
}else{
return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
}
}
};

Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note:
  You must do this in-place without making a copy of the array.
  Minimize the total number of operations.

/**
* @param {number[]} nums
* @return {void} Do not return anything, modify nums in-place instead.
*/
var moveZeroes = function(nums) {
var j = 0;
for( var i = 0; i < nums.length; i++){
if( nums[i] === 0 ) j++;
else{
var tmp = nums[i];
nums[i] = nums[i-j];
nums[i-j] = tmp;
}
}
};

Invert a binary tree.
      4
     / \
    2   7
   / \ / \
   1 3 6 9
to
    4
   / \
  7   2
 / \ / \
9  6 3  1
/**
* Definition for a binary tree node.
* function TreeNode(val) {
* this.val = val;
* this.left = this.right = null;
* }
*/
/**
* @param {TreeNode} root
* @return {TreeNode}
*/
var invertTree = function(root) {
if( !root ) return root;
//if( !root.left && !root.right ) return root;

var tmp = root.left;
root.left = root.right;
root.right = tmp;

invertTree(root.left);
invertTree(root.right);
return root;
};


Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 
Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
    if( !nums.length ) return false;
    var a = [];
    for( var i = 0; i < nums.length; i++){
        if( a[nums[i]] === undefined ) a[nums[i]] = 1;
        else return true;
    }
    
    return false;
};


Given a column title as appear in an Excel sheet, return its corresponding column number.
26进制
For example:

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    if( s === null ) return 0;
    var result = 0;
    var i  = 1;
    var sArray = s.split("");
    while( sArray.length ){
        result += ( sArray.pop().charCodeAt()-64 )  * Math.pow(26,(i-1));
        i++;
    }
    
    return result;
};


http://karlma8812.github.io/algorithm/2014/09/07/BinaryTreeAlgorithm.html 二叉树面试题
Lowest Common Ancestor of a Binary Search Tree
 Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5

For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if( root === null || p === null || q === null ) return [];
    if( root === p || root === q ) return root;
    var pPath = [], qPath = [];
    
    if( !(getNodePath(root, p, pPath) && getNodePath(root, q, qPath))  ){
        return [];
    }
    
    
    var lastCommonPath = root;
    while( pPath.length && qPath.length ){
        var lastPPath = pPath.shift();
        var lastQPath = qPath.shift();
        if( lastPPath === lastQPath ) {
            lastCommonPath = lastPPath;
        }else{
            return lastCommonPath;
        } 
    }
    
    return lastcommonPath;
    
}

function getNodePath(t, node, pathArray){
    if( t === null || node === null) return false;
    
    if( t === node ){
        pathArray.push( t );
        return true;
    }
    
    var found = false;
    pathArray.push( t );
    found = getNodePath(t.left, node, pathArray);
    if( !found ){
        found = getNodePath(t.right, node, pathArray);
    }
    if( !found ){
        pathArray.pop();
    }
    
    return found;
}

Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    if( n < 0 ) return 0;
    var count = 0;
    return divide(n, count);
};

function divide(n, count){
    if( n < 1 ) return count;
    return divide(Math.floor(n/2), (count += n%2) );
}


移动文字：
abcd , bcda, cdba true
abcd , acbd false
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isMovingWord = function(s, t) {
    if( s === t ) return true;
    if( s === null || t === null || s.length !== t.length ) return false;
    var sA = s.split("");
    var flag = sA.length -1 ;
    while( flag ){
        sA.unshift( sA.pop() );
        if( sA.join("") === t ) return true;
        flag--;
    }
    return false;
};

回文
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if( s.length !== t.length) return false;
    var hashS = [];
    var hashT = [];
    for( var i = 0; i < s.length ; i++){
        if( hashS[s[i]] === undefined ) hashS[s[i]] = 1;
        else hashS[s[i]]++;
        
        if( hashT[t[i]] === undefined ) hashT[t[i]] = 1;
        else hashT[t[i]]++;
    }
    
    if( hashS.length !== hashT.length ) return false; 
    
    for( var j in hashS ){
        if( hashT[j] === undefined ) return false;
        if ( hashS[j] !== hashT[j] ) return false;
    }
    
    return true;
}

Major elements
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    var hash = [];
    for( var i = 0; i < nums.length; i++ ){
        if( hash[nums[i]] === undefined ) hash[nums[i]] = 1;
        else hash[nums[i]] += 1;
        
        if( hash[nums[i]] > Math.floor(nums.length/2) ) return nums[i];
    }
    
};

Roman to Integer
Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
     var a ={
        "M" : 1000,
        "D" : 500,
        "C" : 100,
        "L" : 50,
        "X" : 10,
        "V" : 5,
        "I" : 1
     };
     
     var result = a[s[0]], lastNum = a[s[0]];
     
     for( var i = 1; i < s.length; i++){
        if( a[s[i]] <= lastNum ){
            result += a[s[i]];
        }else{
            result = result - 2*lastNum + a[s[i]];
        }
        lastNum = a[s[i]];
     }
     
     return result;
}

Integer to Roman
Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.
http://bangbingsyb.blogspot.com/2014/11/leetcode-integer-to-roman.html
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
        var dict = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"];
        var val = [1000,900,500,400,100,90,50,40,10,9,5,4,1];  
        var ret ="";
        for(var i=0; i<13; i++ ) {
            if( num >= val[i] ) {
                var count = Math.floor(num/val[i]);
                num %= val[i];
                for(var j=0; j<count; j++) {
                    ret += dict[i];
                }
            }
        }
        return ret;
};


Reverse Linked List
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if( head === [] ) return [];
    
   var node = head;
   var previous = null;
   
   while( node ){
       var tmp = node.next;
       node.next = previous;
       previous = node;
       node = tmp;
   }
   
   return previous;
};

Remove Duplicates from Sorted List
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if( head === null ) return [];
    
    var node = head, prev = null, hash = {};
    
    while( node ){
        if( hash[node.val+"a"] === undefined ) {
            hash[node.val+"a"] = 1;
            prev = node;
            node = node.next;
        }else{
            prev.next = node.next;
            node = node.next;
        }
    }
    
    return head;
    
};


Remove Duplicates from Sorted List II
 Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3. 
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if( head === null || head.next === null) return head;
    
    var dummy = new ListNode(0);
    dummy.next = head;
    
    var p = dummy;
    var tmp = dummy.next;
    
    while( p.next ){
        while( tmp.next && p.next.val === tmp.next.val ){
            tmp = tmp.next;
        }
        
        if( tmp === p.next ){
            p = p.next;
            tmp = p.next;
        }else{
            p.next = tmp.next;
        }
    }
    
    return dummy.next;
    
};


Climbing Stairs
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
斐波纳钦数列
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
   /* if( n === 0 ) return 0;
    if( n === 1 ) return 1;
    return climbStairs( n-1 ) + climbStairs( n-2 );*/
    
    var current = 1, last = 0;
    for(var i = 0; i < n; i++ ){
        var tmp = current;
        current += last;
        last = tmp;
    }
    
    return current;
};

isHappyNumber
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    var numsArray = [];
    var result = 0;
    while( true ){
        if( n === 1) return true;
        result = 0;
        var nA = n.toString().split("");
        for( var i = 0; i < nA.length; i++ ){
            result += Math.pow(parseInt(nA[i]),2);
        }
        
        if( numsArray.indexOf( result ) !== -1) return false;
        numsArray.push( result );
        n = result;
    }
};


从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。反之，减去前一个数的两倍然后加上该数   
    /**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
     var a ={
        "M" : 1000,
        "D" : 500,
        "C" : 100,
        "L" : 50,
        "X" : 10,
        "V" : 5,
        "I" : 1
     };
     
     var result = a[s[0]], lastNum = a[s[0]];
     
     for( var i = 1; i < s.length; i++){
        if( a[s[i]] <= lastNum ){
            result += a[s[i]];
        }else{
            result = result - 2*lastNum + a[s[i]];
        }
        lastNum = a[s[i]];
     }
     
     return result;
}

数独验证：

060593000
901000500
030400090
108020004
400309001
200010609
080006020
004000807
000785010

var a =[ [null,6,null,5,9,3,null,null,null],
         [9,null,1,null,null,null,5,null,null],
         [null,3,null,4,null,null,null,9,null],
         [1,null,8,null,2,null,null,null,4],
         [4,null,null,3,null,9,null,null,1],
         [2,null,null,null,1,null,6,null,9],
         [null,8,null,null,null,6,null,2,null],
         [null,null,4,null,null,null,8,null,7],
         [null,null,null,7,8,5,null,1,null]
       ];
        
function validation( a, i,j, validateN ){
  var rowOrigin = Math.floor(i/3) * 3;
  var columnOrigin = Math.floor(j/3)*3;
    
  for( var m = 0; m < 9; m++){
    if( a[i][m] === validateN ) return false;
    if( a[m][j] === validateN ) return false;
    
    if( a[ (rowOrigin+Math.floor(m/3)) ][ (columnOrigin+m%3) ] === validateN ) return false;
  }
  return true;
}

console.log(validation(a, 0,2, 2));


leetcode:

/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
  for( var i = 0; i < 9; i++){
    var hashRow=[], hashColumn=[], hashTable=[];
        
      for( var j = 0; j < 9; j++){
        
        if( board[i][j] !== "." ){
            
            if( hashRow[board[i][j].toString()] === undefined ) hashRow[board[i][j].toString()] = 1;
            else return false;
        }
        
        if( board[j][i] !== "." ){
            if( hashColumn[board[j][i].toString()] === undefined ) hashColumn[board[j][i].toString()] = 1;
            else return false;
        }
        
        
        var r = 3*Math.floor(i/3) + Math.floor(j/3);
        var c = 3*(i%3) + j%3;
        if( board[r][c] !== "." ){
            if( hashTable[board[r][c].toString()] === undefined ) hashTable[board[r][c].toString()] = 1;
            else return false;
        }
      }
  }
  return true;
};

---------------------------------------------------

判断素数：
function isPrime(n){
	if( n < 2 ) return false;
	for( var i = 2; i*i <= n; i++){
		if( n%i === 0 ) return false;
	}
	return true;
}


丑数
丑数只能被2、3和5整除。也就是说如果一个数如果它能被2整除，我们把它连续除以2；如果能被3整除，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的是1，那么这个数就是丑数，否则不是。
/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
    if( num === 0 ) return false;
    
    while( num%2 === 0 ){
        num /= 2;
    }
    while( num%3 === 0 ){
        num /= 3;
    }
    while( num%5 === 0){
        num /= 5;
    }
    
    if( num === 1 ) return true;
    return false;
};


利用stack实现队列mplement Queue using Stacks
/**
 * @constructor
 */
var Queue = function() {
    this.stack = [];
};

/**
 * @param {number} x
 * @returns {void}
 */
Queue.prototype.push = function(x) {
    this.stack.push(x);
    return null;
};

/**
 * @returns {void}
 */
Queue.prototype.pop = function() {
    if( Queue.empty ) return null;
    var popN = this.stack[0];
    for( var i = 1; i < this.stack.length; i++ ){
        this.stack[i-1] = this.stack[i];
    }
    this.stack[this.stack.length-1] = popN;
    this.stack.pop();
    return null;
};

/**
 * @returns {number}
 */
Queue.prototype.peek = function() {
    if( Queue.empty ) return null;
    return this.stack[0];
};

/**
 * @returns {boolean}
 */
Queue.prototype.empty = function() {
    return !this.stack.length;
};


var a = new Queue();
a.push(1);
a.push(2);
a.push(5);
a.push(6);
a.push(8);
a.pop();
a



Merge Two Sorted Lists 

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if( l1 === null ) return l2;
    if( l2 === null ) return l1;
    if( l1 === null && l2 === null ) return null;
    
    var head = new ListNode(0);
    var newList = head;
    var temp = null;
    
    while( l1 !== null && l2 !== null ){
        if( l1.val <= l2.val ){
            temp = l1;
            l1 = l1.next;
        }else{
            temp = l2;
            l2 = l2.next;
        }
        
        newList.next = temp;
        newList = newList.next;
    }
    
    newList.next = l1 === null ? l2 : l1;
    return head.next;
};

Power of Two
Given an integer, write a function to determine if it is a power of two. 
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    if( n === 0 ) return false;
    while( n !== 1 ){
        if( n%2 !== 0 ) return false;
        n = n/2;
    }
    return true;
};

Balanced Binary Tree
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    if( !root ) return true;
    
    var node = root;
    if( Math.abs( getHeight(node.left) - getHeight(node.right) ) > 1 ) return false;
    return isBalanced(node.left) && isBalanced(node.right);
};

var getHeight = function(node){
    if( !node ) return 0;
    return Math.max( getHeight(node.left)+1, getHeight(node.right)+1 ) ;
}

Symmetric Tree

非递归解法：按层遍历，每一层检查一下是否对称。

递归解法：

其中左子树和右子树对称的条件：

    两个节点值相等，或者都为空
    左节点的左子树和右节点的右子树对称
    左节点的右子树和右节点的左子树对称

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if( root === null ) return true;
    return isSym(root.left, root.right);
    
};

var isSym = function(leftNode, rightNode){
    if( leftNode === null) return rightNode === null;
    if( rightNode === null ) return leftNode === null;
    if( leftNode.val !== rightNode.val ) return false;
    if( !isSym(leftNode.left, rightNode.right) ) return false;
    if( !isSym(leftNode.right, rightNode.left) ) return false;
    return true
}

Remove Duplicates from Sorted Array
 Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory. 
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if( !nums.length ) return [];
  var currentIndex = 0, detectIndex = 0;
  while( detectIndex < nums.length){
      if( nums[currentIndex] !== nums[detectIndex] ){
          currentIndex++;
          var tmp = nums[currentIndex];
          nums[currentIndex] = nums[detectIndex];
          nums[detectIndex] = tmp;
      }
      detectIndex++;
  }
  
  /*while( (detectIndex - currentIndex) > 1 ) {
    detectIndex--;
    nums.pop();
  }*/
 //return nums
 return currentIndex+1;
};

removeDuplicates([1,1,1,2,2,3]);

countPrime
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
  if( n <= 2 ) return 0;
  var count = 0;
  for(  var i  = 2; i <= (n-1) ; i++ ){
    if( isPrime(i) ) count++;
  }
  return count;
}


Count the number of prime numbers less than a non-negative number, n.
function isPrime(n){
    if( n < 2 ) return false;
  for( var i = 2; i*i<=n; i++){
    if( n%i === 0 ) return false;
  }
  return true;
}

Merge Sorted Array
Total Accepted: 74443 Total Submissions: 254590 Difficulty: Easy

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

思路：从后往前填
var merge = function(nums1, m, nums2, n) {
    var insertIndex = m+n-1;
    var mIndex = m-1;
    var nIndex = n-1;
    while( insertIndex >= 0 && mIndex >= 0 && nIndex >= 0 ){
        if( nums1[mIndex] > nums2[nIndex] ){
            nums1[insertIndex] = nums1[mIndex];
            mIndex--;
        }else{
            nums1[insertIndex] = nums2[nIndex];
            nIndex--;
        }
        insertIndex--;
    }
    
    while( mIndex >=0 ){
      nums1[insertIndex] = nums1[mIndex];
        mIndex--;
        insertIndex--;
    }
    
    while( nIndex >=0 ){
        nums1[insertIndex] = nums2[nIndex];
        nIndex--;
        insertIndex--;
      console.log("c");
    }
    return nums1;
};

merge([1],1,[],0);


rotate array:
Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. 
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var rotate = function(nums, k) {
  for( var i = 0; i < k; i++){
     nums.unshift( nums.pop() );
  }
};

rotate II: 
var rotate = function(nums, k) {
  return rev(rev(nums.splice(0,nums.length-k)).concat(rev(nums.splice(nums.length-k,k) )));
};

function rev(arr){
    return arr.reverse();
}

rotate([1,2,3,4,5,6,7],3);

roate II.2:
var rotate = function(nums, k) {
  k = k%nums.length;
  rev(nums,0,nums.length-1);
  rev(nums,0,k-1);
  rev(nums,k,nums.length-1);
};

function rev(arr,start,end){
  if(start !== end){
    for(var i = 0; i < Math.floor( (end-start+1)/2 ); i++){
        var tmp = arr[i+start];
        arr[i+start] = arr[end-i];
        arr[end-i] = tmp;
    }
  }
}


Length of Last Word:
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.
var lengthOfLastWord = function(s) {
  var count = 0;
  for( var i = s.length-1; i >=0; i--){
    if( count !== 0 && s[i] === " ") return count;
    else if( s[i] !== " ") count++;
  }
  return count;
};

Valid Palindrome

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome. 

/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    if( s === "" ) return true;
    var filterString = s.toLowerCase().replace(/[^A-Za-z0-9]/g,"");
    return filterString.split("").reverse().join("") === filterString;
};


compare version numbers
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
    if( !version1 && !version2 ) return 0;
    if( version1 === "" ) return -1;
    if( version2 === "" ) return 1;
    version1Array = version1.split(".");
    version2Array = version2.split(".");
    var flag1 = 0;
    var n = version2Array.length;
    if( version1Array.length > version2Array.length) {
        flag1 = 1;
        n = version1Array.length;
    }
    for( var i = 0; i < n; i++){
        if( flag1 === 1 ) version2Array.push(0);
        else version1Array.push(0);
        if( parseInt(version1Array[i]) > parseInt(version2Array[i]) ) return 1;
        else if( parseInt(version1Array[i]) < parseInt(version2Array[i]) ) return -1;
    }
    return 0;
};

Rectangle Area

Find the total area covered by two rectilinear rectangles in a 2D plane.
Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.
/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
    var area = Math.abs((C-A) * (D-B)) + Math.abs((G-E) * (H-F));
    if( A >= G || B >= H || C <= E || D <=F ){
        return area;
    }
    
    var bottomX = Math.max(A,E);
    var bottomY = Math.max(B,F);
    var topX = Math.min(C,G);
    var topY = Math.min(D,H);
    
    return area- Math.abs((topX-bottomX)*(topY-bottomY));
    
};

Pascal's Triangle
Given numRows, generate the first numRows of Pascal's triangle.

For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]



var generate = function(numRows) {
    var tri = [];
    for( var i = 0; i < numRows; i++){
        tri[i] = [1];
        for( var j = 1; j < i+1; j++){
            tri[i].push(tri[i-1][j-1]+tri[i-1][j]);
        }
        tri[i][i] = 1;
    }
    
    return tri;
};

plus one:
[1,4,5,3] -> [1,4,5,4]
[9,9,9,9] -> [1,0,0,0,0]

/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    var i = digits.length - 1;
    var carry = 1;
    while( i >= 0 && carry ){
        if( digits[i] === 9 ){
            carry = 1;
            digits[i] = 0;
        }else{
            digits[i] += 1;
            carry = 0;
        } 
        i--;
    }
    
    if( carry === 1 ){
        digits.unshift(1);
    }
    
    return digits;
};

Summary Ranges
Given a sorted integer array without duplicates, return the summary of its ranges.
For example, given [0,1,2,4,5,7], return ["0->2","4->5","7"]. 
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {
    if( !nums.length ) return [];
    var range = [];
    var prev = nums[0];
    var rangeBegin = nums[0];
    if( nums.length === 1 ) return [ rangeBegin.toString() ];
    for( var i = 1; i < nums.length; i++ ){
        if( nums[i] - prev === 1){
            prev = nums[i];
            if( i === nums.length-1 ){
                range.push( rangeBegin.toString() + "->" + nums[i].toString() );
            }
        }else{
            if( rangeBegin === prev ){
                range.push( rangeBegin.toString() );
            }else{
                range.push( rangeBegin.toString() + "->" + prev.toString() );
            }
            if( i === nums.length-1 ){
                range.push( nums[i].toString() );
            }
            prev = nums[i];
            rangeBegin = nums[i];
        }
    }
    return range;
};

Pascal's Triangle II
Given an index k, return the kth row of the Pascal's triangle.
For example, given k = 3,
Return [1,3,3,1]. 
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    if( rowIndex === 0 ) return [1];
    var result = [1,1];
    for( var i = 2; i <= rowIndex ; i++ ){
        result.push(1);
        for( var j = i-1; j > 0 ; j-- ){
            result[j] = result[j]+ result[j-1];
        }
    }
    return result;
};


Path Sum
 Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if( root === null ) return false;
    if( root.val === sum){
        if( root.left === null && root.right === null){
            return true;       
        }
    }
    return (hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val));
}; 

Min Stack
/**
 * @constructor
 */
var MinStack = function() {
    this.mStack = [];
};

/**
 * @param {number} x
 * @returns {void}
 */
MinStack.prototype.push = function(x) {
    this.mStack.push(x);
};

/**
 * @returns {void}
 */
MinStack.prototype.pop = function() {
    this.mStack.pop();
};

/**
 * @returns {number}
 */
MinStack.prototype.top = function() {
    return this.mStack[this.mStack.length-1];
};

/**
 * @returns {number}
 */
MinStack.prototype.getMin = function() {
    var minVal = this.mStack[0];
    for( var i = 1; i < this.mStack.length; i++){
        minVal = minVal >= this.mStack[i] ? this.mStack[i] : minVal;
    }
    return minVal;
};


Palindrome Linked List
Given a singly linked list, determine if it is a palindrome.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    
    if( head === null || head.next === null ) return true;
    
    var slow = head, fast = head, cacheHead = head;
    while( fast !== null && fast.next !== null ){
        slow = slow.next;
        fast = fast.next.next;
    }
    
    var rev = new ListNode("head"),tmp;
    while( slow !== null ){
        tmp = slow;
        slow = slow.next;
        tmp.next = rev.next;
        rev.next = tmp;
    }
    
    var ori = cacheHead, compare = rev.next;
    while( ori !== null && ori.next !== null){
        if( ori.val !== compare.val) return false;
        ori = ori.next;
        compare = compare.next;
    }
    
    return true;
};

Binary Tree Level Order Traversal II

Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

return its bottom-up level order traversal as:

[
  [15,7],
  [9,20],
  [3]
]
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function(root) {
   var res = [];
   if( root === null ) return res;
   var levelToProcess = [root];
   while( levelToProcess.length > 0){
       numbersLevel = [];
       nextLevel = [];
       for( var i = 0; i < levelToProcess.length; i++ ){
           numbersLevel.push( levelToProcess[i].val );
           if( levelToProcess[i].left !== null ){
               nextLevel.push( levelToProcess[i].left);
           }
           if( levelToProcess[i].right !== null ){
               nextLevel.push( levelToProcess[i].right);
           }
       }
       res.push( numbersLevel);
       levelToProcess = nextLevel;
   }
   
   return res.reverse();
};


Contains Duplicate II
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. 
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    var arr = [];
    for( var i = 0; i < nums.length; i++ ){
        if( arr[nums[i]] === undefined) arr[nums[i]] = i;
        else{
            if( (i - arr[nums[i]]) <= k ) return true;
            else arr[nums[i]] = i;
        }
    }
    return false;
};


Implement Stack using queues
/**
 * @constructor
 */
var Stack = function() {
    this.queue = [];
};

/**
 * @param {number} x
 * @returns {void}
 */
Stack.prototype.push = function(x) {
    this.queue[this.queue.length] = x;
};

/**
 * @returns {void}
 */
Stack.prototype.pop = function() {
    return this.queue.splice(this.queue.length-1,1);
};

/**
 * @returns {number}
 */
Stack.prototype.top = function() {
    return this.queue[this.queue.length-1];
};

/**
 * @returns {boolean}
 */
Stack.prototype.empty = function() {
    return !this.queue.length;
};

Excel Sheet Column Title
Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
/**
 * @param {number} n
 * @return {string}
 */
var convertToTitle = function(n) {
    if( n <= 0 ) return false;
    if( n <= 26 ) return String.fromCharCode(n+64);
    
    var result = ""; 
    while( Math.floor(n/26) !== 0 ){
        var firstBit = 0;
        if(n%26 === 0){
            firstBit = 26;
            n -= 26;
        }else{
            firstBit = n%26;
        }
        result += String.fromCharCode(firstBit+64);
        n = Math.floor(n/26);
    }
    if( n !== 0 ) result += String.fromCharCode(n+64);
    
    return result.split("").reverse().join("");
};


House Robber
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
这道题的本质相当于在一列数组中取出一个或多个不相邻数，使其和最大。那么我们对于这类求极值的问题首先考虑动态规划Dynamic Programming来解，我们维护一个一位数组dp，其中dp[i]表示到i位置时不相邻数能形成的最大和，经过分析，我们可以得到递推公式dp[i] = max(num[i] + dp[i - 2], dp[i - 1]), 由此看出我们需要初始化dp[0]和dp[1]，其中dp[0]即为num[0]，dp[1]此时应该为max(num[0], num[1])，代码如下：
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if( !nums.length ) return 0;
    if( nums.length === 1 ) return nums[0];
    var dp = [ nums[0], Math.max(nums[0], nums[1])];
    for( var i = 2; i < nums.length; i++){
         dp.push( Math.max( dp[i-1], dp[i-2] + nums[i] ) );    
    }
    return dp.pop();
};


Factorial Trailing Zeroes
考虑n!的质数因子。后缀0总是由质因子2和质因子5相乘得来的。如果我们可以计数2和5的个数，问题就解决了。考虑下面的例子：
n = 5: 5!的质因子中 (2 * 2 * 2 * 3 * 5)包含一个5和三个2。因而后缀0的个数是1。
n = 11: 11!的质因子中(2^8 * 3^4 * 5^2 * 7)包含两个5和三个2。于是后缀0的个数就是2。
我们很容易观察到质因子中2的个数总是大于等于5的个数。因此只要计数5的个数就可以了。那么怎样计算n!的质因子中所有5的个数呢？一个简单的方法是计算floor(n/5)。例如，7!有一个5，10!有两个5。除此之外，还有一件事情要考虑。诸如25，125之类的数字有不止一个5。例如，如果我们考虑28!，我们得到一个额外的5，并且0的总数变成了6。处理这个问题也很简单，首先对n÷5，移除所有的单个5，然后÷25，移除额外的5，以此类推。下面是归纳出的计算后缀0的公式。
n!后缀0的个数 = n!质因子中5的个数
              = floor(n/5) + floor(n/25) + floor(n/125) + ....

Given an integer n, return the number of trailing zeroes in n!.
var trailingZeroes = function(n) {
    var result = 0;
    var m = 5;
    while( n >= m ){
        result += Math.floor( n/m );
        m *= 5;
    }
    return result;
};


Isomorphic Strings

Given two strings s and t, determine if they are isomorphic.

Two strings are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

For example,
Given "egg", "add", return true.

Given "foo", "bar", return false.

Given "paper", "title", return true.
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
  var sA = s.split("");
  var tA = t.split("");
  var hashMap = [], hashMap2 = [];
  for( var i = 0, j = sA.length; i < j; i++ ){
    var sAPop = sA.pop();
    var tAPop = tA.pop();
    if( hashMap[sAPop] === undefined ){
        hashMap[sAPop] = tAPop;
    }else{
        if( hashMap[sAPop] !== tAPop ) return false;    
    }
    
    if( hashMap2[tAPop] === undefined){
        hashMap2[tAPop] = sAPop;
    }else{
       if( hashMap2[tAPop] !== sAPop ) return false;
    }
    
  }
  return true;
};


Add Binary
Given two binary strings, return their sum (also a binary string).

For example,
a = "11"
b = "1"
Return "100". 
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    var carry = 0;
    var sa = a.split("");
    var sb = b.split("");
    var result = [];
    var firstBit, secondBit,ra, rb;
    while( sa.length && sb.length ){
        firstBit = sa.pop();
        secondBit = sb.pop();
        ra = ( firstBit === secondBit ) ? 0 : 1;
        rb = ( carry === ra ) ? 0 : 1;
        if( parseInt(firstBit) + parseInt(secondBit) + carry > 1 ) carry = 1;
        else carry = 0;
        result.unshift(rb);
    }
    while( sa.length){
        firstBit = parseInt(sa.pop());
        ra = ( firstBit === carry ) ? 0 : 1; 
        if( firstBit && carry ) carry = 1;
        else carry = 0;
        result.unshift(ra);
    }
    
    while( sb.length){
        firstBit = parseInt(sb.pop());
        rb = ( firstBit === carry ) ? 0 : 1; 
        if( firstBit && carry ) carry = 1;
        else carry = 0;
        result.unshift(rb);
    }
    
    if( carry === 1 ) result.unshift(1);
    
    return result.join("");
};


word pattern
Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Examples:

    pattern = "abba", str = "dog cat cat dog" should return true.
    pattern = "abba", str = "dog cat cat fish" should return false.
    pattern = "aaaa", str = "dog cat cat dog" should return false.
    pattern = "abba", str = "dog dog dog dog" should return false.

Notes:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. 
/**
 * @param {string} pattern
 * @param {string} str
 * @return {boolean}
 */
var wordPattern = function(pattern, str) {
    var strArray = str.split(" ");
    if( strArray.length !== pattern.length ) return false;
    //map
    var hashMap = [], hashMap2 = [];
    for( var i = 0; i < strArray.length; i++){
        if( hashMap[pattern[i]] === undefined ) hashMap[pattern[i]] = strArray[i];
        else{
            if( hashMap[pattern[i]] !== strArray[i] ) return false;
        }
        
        if( hashMap2[strArray[i]] === undefined ) hashMap2[strArray[i]] = pattern[i];
        else{
            if( hashMap2[strArray[i]] !== pattern[i] ) return false;
        }
    }
    return true;
};

Range Sum Query - Immutable
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:

Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3

Note:

    You may assume that the array does not change.
    There are many calls to sumRange function.

考虑到要多次调用sumRange()函数，因此需要把结果先存起来，调用时就可以直接返回了。最开始考虑的是用dp[i][j]来直接存储i到j之间元素的和，但是内存超出限制。于是考虑用dp[i]来存储0到i之间元素的和，0到j的和减去0到i-1的和即为所求。
/**
 * @constructor
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.nums = nums;
    this.dp = [];
    this.dp[0] =  nums[0];
    for( var i = 1; i < nums.length; i++){
        this.dp[i] = nums[i] + this.dp[i-1];
    }
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
    return i === 0 ? this.dp[j] : this.dp[j] - this.dp[i-1];
};


/**
 * Your NumArray object will be instantiated and called as such:
 * var numArray = new NumArray(nums);
 * numArray.sumRange(0, 1);
 * numArray.sumRange(0, 2);
 */



Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings. 
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if( !strs.length ) return "";
    var flag = 1, j = 0;
    var commonPrefix = "";
    while( flag ){
        if( strs[0][j] === undefined ){
            flag = 0;
            break;
        }
        commonPrefix += strs[0][j];
        for( var i = 0; i < strs.length; i++){
            if( strs[0][j] !== strs[i][j] ) {
                flag = 0;
                commonPrefix = commonPrefix.substr(0,commonPrefix.length-1);
                break;
            }
        }
        j++;
    }
    
    return commonPrefix;
};


Count and Say
The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth sequence. 

/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    if( n === 1) return "1";
    //if( n === 2) return "11";
    var result = "1", prev = "1", count = 0;
    for( var i = 1; i < n; i++ ){
        var resArray = result.split("");
        result = "";
        prev = resArray[0];
        for( var j = 0; j < resArray.length; j++ ){
            if( resArray[j] === prev ){
                count++;
            }else{
                result += count.toString()+prev;
                prev = resArray[j];
                count = 1;
            }
        }
        result += count.toString()+prev;
        count = 0;
    }
    return result;
};

Bulls and Cows
思路： 先遍历secret 创建hash纪录出现次数同时对比guess,记入a，如有配对成功则减去对应出现次数，接着遍历guess，检测b
You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.

For example:

Secret number:  "1807"
Friend's guess: "7810"

Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)

Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return "1A3B".

Please note that both secret number and friend's guess may contain duplicate digits, for example:

Secret number:  "1123"
Friend's guess: "0111"

In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return "1A1B".

You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.
/**
 * @param {string} secret
 * @param {string} guess
 * @return {string}
 */
var getHint = function(secret, guess) {
    var hash = [], a = 0, b= 0;
    
    for( var i = 0; i < secret.length; i++ ){
        if( hash[secret[i]] === undefined ) hash[secret[i]] = 1;
        else hash[secret[i]]++;
        if( guess[i] === secret[i] ) {
            a++;
            hash[secret[i]]--;
        }
    }
    
    for( var j = 0; j < guess.length; j++){
        if( hash[guess[j]] !== undefined && hash[guess[j]] > 0 &&  guess[j] !== secret[j]  ){
            b++;
            hash[guess[j]]--;
        }
    }
    
    return a+"A"+b+"B";
};



Remove Linked List Elements
Remove all elements from a linked list of integers that have value val.
Example
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5 
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
    if( head === null ) return [];
    var prev = null;
    if( head.val === val ) head = head.next;
    var node = head;
    while( node !== null ){
        if( node.val !== val ){
            prev = node;
        }else{
            if( prev !== null ) prev.next = node.next;
            else head = head.next;
        }
        node = node.next;
    }
    
    return head;
};

Intersection of Two Linked Lists
思路： 长度相差
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

begin to intersect at node c1.

Notes:

    If the two linked lists have no intersection at all, return null.
    The linked lists must retain their original structure after the function returns.
    You may assume there are no cycles anywhere in the entire linked structure.
    Your code should preferably run in O(n) time and use only O(1) memory.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if( headA === null || headB === null ) return null;
    
    var al = getLength(headA);
    var bl = getLength(headB);
    var cur;
    var gap = al - bl;
    if( gap > 0 ){
        cur = headA;
        while( gap > 0 ){
            cur = cur.next;
            gap--;
        }
        
        while( cur !== null ){
            if( cur.val === headB.val ) return cur;
            cur =  cur.next;
            headB = headB.next;
        }
        
    }else{
        cur = headB;
        while( gap < 0){
            cur = cur.next;
            gap++;
        }
        
        while( cur !== null ){
            if( cur.val === headA.val ) return cur;
            cur = cur.next;
            headA = headA.next;
        }
    }
    
    return null;
    
};

var getLength = function(node){
   var length = 0;
   while( node !== null ){
       node = node.next;
       length++;
   }
    return length;
};


String to Integer (atoi)
Implement atoi to convert a string to an integer.

Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 
The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 


/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
    var strNoSpace = str.trim();
    var i = 0, j = 0, result = 0, sign= "+";
    
    if( strNoSpace[i] === "-" ) {
        sign = "-"; 
        i++;
    }else if( strNoSpace[i] === "+" ){
        sign = "+";
        i++;
    }
    
    while( i < strNoSpace.length ){
        if( strNoSpace[i].charCodeAt(0) >= 48 && strNoSpace[i].charCodeAt(0) <= 57 ){
            
            result = result*10 + 1*strNoSpace[i];
        
            if( sign === "+" && result >= 2147483647) return 2147483647;
            else if( sign === "-" && result >= 2147483648 ) return -2147483648;
        }else{
            if( strNoSpace[i] === "" ) return 0;
            break;
        }
        j++;
        i++;
    }
    
    return sign === "+" ? result : (0-result);
};


Binary Tree Paths
 Given a binary tree, return all root-to-leaf paths.

For example, given the following binary tree:

   1
 /   \
2     3
 \
  5

All root-to-leaf paths are:

["1->2->5", "1->3"]
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    var res = [];
    if( root !== null ) traverse(root, root.val.toString());
    return res;
    
    function traverse(node, path){
        var isLeaf = true;
        
        if( node.left ){
            isLeaf = false;
            traverse( node.left, path + "->" + node.left.val );
        }
        
        if( node.right ){
            isLeaf = false;
            traverse( node.right, path + "->" + node.right.val );
        }
        
        if( isLeaf ){
            res.push( path );
        }
    }
};


Binary Tree Level Order Traversal

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    var res = [];
    if( root === null ) return [];
    var levelToProcess = [root];
    while( levelToProcess.length > 0 ){
        var numbersLevel = [];
        var nextLevel = [];
        for( var i = 0; i < levelToProcess.length; i++ ){
            numbersLevel.push( levelToProcess[i].val );
            if( levelToProcess[i].left !== null ) nextLevel.push(levelToProcess[i].left);
            if( levelToProcess[i].right !== null ) nextLevel.push(levelToProcess[i].right);
        }
        res.push(numbersLevel);
        levelToProcess = nextLevel;
    }
    return res;
};


Minimum Depth of Binary Tree
思路： 该树为一个空树，则其最小深度为0；
2. 该树不为空且其左右子树都不为空，则最小深度为左子树最小深度和右子树最小深度中较小的那一个+1；
3. 该树不为空，但是其左子树为空，右子树不为空，则最小深度为右子树的最小深度+1；
4. 该树不为空，但是其左子树不为空，右子树为空，则最小深度为左子树的最小深度+1；
5. 该树不为空，但是其左子树和右子树都为空，则最小深度为1；

Given a binary tree, find its minimum depth.
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
  var count = 1;
  if( root === null ) return 0;
  if( root.left === null && root.right === null ) return count;
  if( root.left !== null && root.right === null ) count += minDepth(root.left);
  if( root.right !== null && root.left === null ) count += minDepth(root.right);
  if( root.right !== null && root.left !== null ) count += Math.min(minDepth(root.left),minDepth(root.right));
  return count
};



Reverse Bit
Reverse bits of a given 32 bits unsigned integer.

For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    if(n > 4294967294) return n;
    var res = 0;
    var sign = n & 1;
    n >>= 1;
    for( var i = 0; i < 31; i++){
        res <<= 1;
        res = res | ( n & 1 );
        n >>= 1;
    }
    
    if( sign === 1 ) res += 2147483648;
    return res;
};

Single Number
Given an array of integers, every element appears twice except for one. Find that single one.
思路：
利用位异或来得出最后单个数字：
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    var a = 0;
    for( var i = 0;  i < nums.length; i++){
        a = nums[i] ^ a;
    }
    
    return a;
};

Single Number II
思路：对每位求和 最后做％3 这样就能对出现三次的归0
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    var result = 0;
    
    for( var i = 31; i >=0; i--){
        var sum = 0;
        var mask = 1 << i;
        for( var j = 0; j < nums.length; j++){
            if( nums[j] & mask ) sum++;
        }
        
        result = ( result << 1 ) + ( sum%3 );
    }
    
    return result;
    
};


1 left 0 right:
Move all 1 to left and 0 to right
[1,0,0,1,1,1,0,0,1] -> [1,1,1,1,1,0,0,0,0]

var one = function(nums){
  var i = 0, j = nums.length-1;
  
  while( i < j ){
    if( nums[i] === 1 ) i++;
    if( nums[j] === 0 ) j--;
    if( nums[i] === 0 && nums[j] === 1 ){
      nums[i] = 1;
      nums[j] = 0;
      i++;
      j--
    }
    console.log(nums);
  }
  
  return nums;
}


Single Number III
Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

For example:

Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. 
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function(nums) {
    var xor = 0;
    for( var i = 0; i < nums.length; i++){
        xor ^= nums[i];
    }
    
    var diff = 1;
    while( ( diff & xor ) !== diff ){
        diff = diff << 1;
    }
    
    var target0 = 0;
    for( var j = 0; j < nums.length; j++){
        if( ( diff & nums[j] ) === diff ){
            target0 ^= nums[j];
        }
    }
    
    var target1 = target0 ^ xor;
    
    return [target0, target1];
};


Sort Colors

Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. 
思路 设置左右指针和detect指针，用detect指针去判断然后交换值

var sortColors = function(nums) {
  var i = 0, k = 0, j = nums.length - 1;
  
  while( k <= j){
   
    if( nums[k] === 0 ){
      nums[k] = nums[i];
      nums[i] = 0;
      i++;
      k++;
    }
    
    else if( nums[k] === 2){
      nums[k] = nums[j];
      nums[j] = 2;
      j--;
    }
    
    else{
      k++;
    }
    
  }
};


sqrt(x)
思路： 牛顿迭代法
xi+1 ＝ (xi + n/xi) / 2。
last和res之间的差值要小于1
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    if( x === 0 ) return 0;
    var res = 1, last = 0;
    
    while( Math.abs(last - res) >= 1 ){
        last = res;
        res = (last+ x/last)/2;
    }
    
    return Math.floor(res);
    
};

Rotate Image
顺时针旋转90度

/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    var n = matrix.length;
    for( var i = 0; i <= Math.floor(n/2); i++){
        for( var j = i; j < n-i-1; j++){
            var tmp = matrix[i][j];
            matrix[i][j] = matrix[n-1-j][i];
            matrix[n-1-j][i] = matrix[n-1-i][n-1-j];
            matrix[n-1-i][n-1-j] = matrix[j][n-1-i];
            matrix[j][n-1-i] = tmp;
        }
    }
};


Best Time to Buy and Sell Stock II
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

思路：区别是这里可以交易无限多次（当然我们知道交易不会超过n-1次，也就是每天都进行先卖然后买）。既然交易次数没有限定，可以看出我们只要对于每次两天差价大于0的都进行交易，就可以得到最大利润。因此算法其实就是累加所有大于0的差价既可以了，非常简单。如此只需要一次扫描就可以了

/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    if( prices.length === 0 ) return 0;
    var res = 0;
    var prev = prices[0];
    
    for( var i = 1; i < prices.length; i++ ){
        var tmp = prices[i] -prev;
        prev = prices[i];
        
        if( tmp > 0 ) res+= tmp;
    }
    
    return res;
};

Product of Array Except Self
 Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6]. 
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    
    if( nums.length <= 1 ) return nums;
    
    var result = [];
    result[0] = 1;
    var left = 1, right = 1;
    
    for( var i = 1; i < nums.length; i++ ){
        left = left * nums[i-1];
        result[i] = left;
    }
    
    for( var j = nums.length-2; j >= 0; j-- ){
        right = right * nums[j+1];
        result[j] *= right;
    }
    
    return result;
};



Missing number
 Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

For example,
Given nums = [0, 1, 3] return 2. 
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    
    /*var res = 0;
    for( var i  = 0; i < nums.length; i++ ){
       res ^= (i+1) ^ nums[i];
    }
    return res;*/
    
    var sum = 0, n = nums.length;
    for( var i  = 0; i < nums.lenght; i++){
        sum += nums[i];
    }
    
    return 0.5*n*(n+1)-sum;
    
};

Container With Most Water
前后指针， 值小的是瓶颈所以移动值小的
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. 
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    var maxArea = 0;
    var front = 0;
    var last = height.length-1;
    while( front < last ){
        var area = ( last-front ) * Math.min(height[front], height[last]);
        if( area > maxArea ) maxArea = area;
        if( height[front] < height[last] ){
            front++;
        }else{
            last--;
        }
    }
    
    return maxArea;
};

Pow(x,n)
思路： 利用递归方法
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
    if( x === 0 ) return 0;
    if( n === 0 ) return 1;
    if( n < 0 ){
        n = -n;
        x = 1/x;
    }
    
    var tmp = myPow(x,Math.floor(n/2) );
    return ( n%2 === 0 ) ? tmp * tmp : tmp * tmp * x;
};

Reverse Words in String
 Given an input string, reverse the string word by word.

For example,
Given s = "the sky is blue",
return "blue is sky the". 
/**
 * @param {string} str
 * @returns {string}
 */
var reverseWords = function(str) {
    var res = "";
    var revStr = str.split(" ");
    for( var i = revStr.length-1; i >=0 ; i--){
        if( revStr[i] !== "") res += " "+revStr[i];
    }
    return res.trim();
};

Ugly Number II
 Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

Note that 1 is typically treated as an ugly number. 
/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
    var nums = [];
    var n2=0, n3=0, n5=0;
    var i = 1;
    nums[0] = 1;
    while( i < n ){
        var uglyNumber = Math.min( (nums[n2]*2), (nums[n3]*3), (nums[n5]*5) );
        nums[i] = uglyNumber;
        if( uglyNumber === nums[n2]*2 ) n2++;
        if( uglyNumber === nums[n3]*3 ) n3++;
        if( uglyNumber === nums[n5]*5 ) n5++;
        i++
    }
    
    return nums[n-1];
};

Trapping Rain Water

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example,
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. 
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    var left = [],right = [], res = 0;
    
    for( var i = 0; i < height.length; i++ ){
        left[i] = i > 0 ? Math.max(left[i-1], height[i]) : height[i];
    }
    
    for( var j = height.length-1; j >= 0; j-- ){
        right[j] = j < height.length-1 ? Math.max(right[j+1], height[j]) : height[j];
    }
    
    for( var k = 1; k < height.length; k++){
        var lowBar = Math.min( left[k-1], right[k+1]);
        if( lowBar > height[k]){
            res += lowBar - height[k];
        }
    }
    
    return res;
};



Longest Palindromic Substring

Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
/**
 * @param {string} s
 * @return {string}
 */

超时算法
var longestPalindrome = function(s) {
    if(s.length === 1 ) return s;
    var maxPN = 0;
    var maxP = "";
    
    for( var i = 0; i < s.length; i++){
        for( var j = i; j < s.length; j++ ){
            var tmp = s.substring(i,j+1);
            if (tmp.isPalindrome()){
                if( tmp.length >= maxPN ){
                    maxPN = tmp.length;
                    maxP = tmp;
                }
            }
        }
    }
    return maxP;
};

String.prototype.isPalindrome = function(){
    return this.toString() === this.split("").reverse().join("");
}

Another way but still time exceed
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if(s.length === 1 ) return s;
    var maxLen = 0;
    var maxString = "";
    var c = new Array(1000);
    var start = 0;
    
    for(var m = 0; m < 1000; m++){
        c[m] = new Array(1000);
    }
    
    for( var i = s.length - 1; i >= 0; i-- ){
        for( var j = i; j < s.length; j++ ){
            if( s[i] === s[j] && ( ( i+1 > j-1) || c[i+1][j-1] ) ){
                c[i][j] = true;
                if(j-i+1>maxLen) {
                    maxLen = j-i+1;
                    start = i;
                }
            }
        }
    }
    return s.substr(start,maxLen);
};

Decode Ways
思路 动态分布
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26

Given an encoded message containing digits, determine the total number of ways to decode it.

For example,
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2. 

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    var n = s.length;
    if( n === 0 || s[0] === '0' ) return 0;
    if( n === 1 ) return 1;
    
    var h = [];
    h[0] = 1 , h[1] = 1;
     
    for( var i = 2; i <= s.length; i++ ){
        if( s[i-1] === '0' ){
            if( s[i-2] < 3 && s[i-2] > 0){
                h[i] = h[i-2];
            }else return 0;
        }else if( s[i-2] === "1" || ( s[i-2] ==="2" && s[i-1] <= 6 ) ){
            h[i] = h[i-1] + h[i-2];
        }else{
            h[i] = h[i-1];
        }
    }
    console.log(h);
    return h[h.length-1];
};

[5,5,5,3,3,4,5,7]
=> ["5:3","3:2",4,5,7]

/*
 * Complete the function below.
 */
function pack(arr) {
    var result = [];
    var cur = 1; pre = 0, curWord = arr[0],count = 1;
    
    while( cur <= arr.length){
        if( arr[cur] === arr[pre] ){
            count += 1;
            cur++;
        }else{
            if(count !== 1){
                result.push( curWord+":"+count);
            }else{
                result.push( curWord);           
            }    
            count = 0;
            curWord = arr[cur];
            pre = cur;
        }
    }
    
    return result;
}

Populating Next Right Pointers in Each Node
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

    You may only use constant extra space.
    You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

For example,
Given the following perfect binary tree,

         1
       /  \
      2    3
     / \  / \
    4  5  6  7

After calling your function, the tree should look like:

         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL


/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
    if( root !== null ){
    
        if( root.left ) root.left.next = root.right;
        if( root.right ) root.right.next = root.next ? root.next.left : null;
        connect( root.left );
        connect( root.right );
    }
};


Search Insert Position
思路： 2分法
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0 
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    var mid = Math.floor( nums.length / 2 ), tmp, index = 0;
    if( target ===  nums[mid] ) return mid;
    else if ( target < nums[mid] ) {
        if( mid === 0) return 0;
        tmp = nums.slice(0, mid);
        index += searchInsert(tmp, target);
    }else{
        if( mid === 0 ) return 1;
        tmp = nums.slice( mid, nums.length);
        index = mid + searchInsert(tmp, target);
    }
    
    return index;
};


H-index:
/**
 * @param {number[]} citations
 * @return {number}
 */
var hIndex = function(citations) {
    var hIndex = 0;
    citations.sort(function(a,b){
        return a - b;
    });
    
    for( var i = 0; i < citations.length; i++ ){
        if( citations.length - i <= citations[i]  ){
            return citations.length - i;
        }
    }
    
    return 0;
};

H-Index II My Submissions Question
Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?j
/**
 * @param {number[]} citations
 * @return {number}
 */
var hIndex = function(citations) {
    var head = 0, tail = citations.length - 1 ;
    var mid;
    
    while( head <= tail ){
        mid = Math.floor( ( head + tail ) / 2 );
        if( ( citations.length - mid ) > citations[mid] ){
            head = mid + 1;
        }else{
            tail = mid - 1;
        }
    }
    
    return citations.length - head;
};


set Matrix Zeroes
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 
O(1);
思路：用第一行和第一列作为标记
先纪录第一行和第一列是否最后要变为0
然后扫描剩下的数，遇到0就讲对应的行列顶置0
然后执行扫描归零
最后在执行第一行和第一列是否为0
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function(matrix) {
    var colZero = false, rowZero = false;
    var m = matrix.length;
    var n = matrix[0].length;
    
    for( var i = 0; i < m; i++ ){
        if( matrix[i][0] === 0 ) rowZero = true;
    }
    
    for( var j = 0; j < n; j++ ){
        if( matrix[0][j] === 0 ) colZero = true;
    }
    
    for( var x = 1; x < m; x++ ){
        for( var y = 1; y <n; y++ ){
            if( matrix[x][y] === 0 ){
                matrix[x][0] = 0;
                matrix[0][y] = 0;
            } 
        }
    }
    
    for( var l = 1; l < m; l++ ){
        for( var k = 1; k < n; k++ ){
            if( matrix[l][0] === 0 || matrix[0][k] === 0){
                matrix[l][k] = 0;
            }
        }
    }
    
    if( colZero ){
        for( i = 0; i < n; i++ ) matrix[0][i] = 0;
    }
    
    if( rowZero ){
        for( i = 0; i < m; i++ ) matrix[i][0] = 0;
    } 
};

Gray code
思路： 
n = 1: 0, 1
n = 2: 0,1,1,0-> 00,01,11,10
n =3: 00,01,11,10,10,11,01,00-> 000,001,011,010,110,111,101,100

/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    if( n === 0 ) return [0];
    var originalN = [0,1], reflectN, i = 1;
    
    while( i < n ){
        
        reflectN = [];
        for( var j = originalN.length - 1; j >= 0; j-- ){
           
            var tmp = originalN[j].toString(2).split("");
            while( tmp.length < i) tmp.unshift("0");
            tmp.unshift("1");
            reflectN.push( parseInt(tmp.join(""),2) );
           
        }
        originalN = originalN.concat(reflectN);  
        i++;
    }
    
    return originalN;
};

Fraction to Recurring Decimal My Submissions Question
思路：
1. 判断符号
2. 获取整数部分
3. 余数为零直接返回
	3.1 余数不为零， 不断除，知道num为0 说明是有限小数
		3.1.1 num先乘10再除获取每位小数
		3.1.2 获取余数，放入hash检测，发现重复的说明为循环小数，返回当前指针和第一次出现该数的位置，跳出循环
		3.1.3 如果没有重复 将被除数乘10去余数， 指针＋1
	3.2 拼接
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

For example,

Given numerator = 1, denominator = 2, return "0.5".
Given numerator = 2, denominator = 1, return "2".
Given numerator = 2, denominator = 3, return "0.(6)".
Credits:
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function(numerator, denominator) {
   if( !numerator || !denominator ) return '0';
    var sign = "";
    
    var result = numerator / denominator;
    if( ( numerator % denominator) === 0 ) return result.toString();
    if( result < 0 ) sign = "-";
    
    var num = Math.abs(numerator);
    var den = Math.abs(denominator);
    
    var res = sign + Math.floor( num/den ) + ".";
    
    if( num%den !== 0 ){
        var hash = {}, frac="", start = 0,end = 0,cur = 0, mod;
        num = num % den;
        while( num ){
         
            frac += Math.floor( ( num * 10 ) / den ).toString();
            
            mod =  num  % den ;
            if( hash[mod] === undefined ) hash[mod] = cur;
            else{
                
                start = hash[mod];
                end = cur;
                break;
            }
            num = ( num * 10 ) % den ;
            cur++;
        } 
        
        if( start !== end ) frac = frac.substring(0,start) + "(" + frac.substring(start, end) + ")";
    }
    
    return res + frac;  
};

Basic Calculator
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    var stack = [];
        stack.push(1);
        stack.push(1);
        var res = 0;
        for(var i=0; i<s.length; i++){
            var tmp = s[i];
            if( /[0-9]/.test(tmp) ){
                var num = parseInt(tmp);
                var j = i+1;
                while(j<s.length && /[0-9]/.test(s[j])){
                    num = num * 10 + parseInt(s[j]);
                    j++;
                }
                i = j-1;
                res += stack.pop() * num;
            }else if(tmp == '+' || tmp == '('){
                stack.push(stack[stack.length-1]);
            }else if(tmp == '-'){
                stack.push(-1*stack[stack.length-1]);
            }else if(tmp == ')'){
                stack.pop();
            }
        }
        return res;
};

Multiply Strings

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
    if( num1 === "0" || num2 === "0") return "0";
    
    num1 = num1.split("").reverse().join("");
    num2 = num2.split("").reverse().join("");
    var res = [];
    for( var k = 0; k < (num1.length+num2.length); k++){
        res[k] = 0;
    }
    
    for( var i = 0; i < num2.length; i++){
        var carry = 0;
        for( var j = 0; j < num1.length; j++){
            carry += parseInt(num1[j]) * parseInt(num2[i]) + res[i+j];
            
            res[i+j] = carry % 10;
            carry = Math.floor(carry / 10);
        }
        if( carry !== 0 ) res[i+ num1.length] += carry;
    }
    
    while( res.length ){
        if( res[res.length-1] === 0 ) res.pop();
        else break;
    }
    
    return res.reverse().join("");
};

Binary Tree Preorder Traversal
前序遍历
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if( root === null ) return [];
    var stack = [];
    var res = [];
    
    while( root !== null || stack.length ){
        if( root !== null ){
            res.push( root.val );
            stack.push(root);
            root = root.left;
        }else{
            root = stack.pop();
            root = root.right;
        }
    }
    
    return res;
};


Binary Tree Inorder Traversal
中序
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    if( root === null ) return [];
    var res = [];
    var stack = [];
    
    while( root !== null || stack.length ){
        if( root !== null ){
            stack.push( root );
            root = root.left;
        }else{
            root = stack.pop();
            res.push(root.val);
            root = root.right;
        }
    }
    
    return res;
};

Binary postorder
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    
    if(root === null ) return [];
    var res = [], stack = [], pre = null;
    
    while( root !== null || stack.length ){
        if( root !== null ){
            stack.push(root);
            root = root.left;
        }else{
            var lastNode = stack[stack.length-1];
            if( lastNode.right !== null  && pre !== lastNode.right ){
                root = lastNode.right;
            }else{
                stack.pop();
                res.push(lastNode.val);
                pre = lastNode;
            }
        }
        
    }
    
    return res;
};

Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

    Integers in each row are sorted from left to right.
    The first integer of each row is greater than the last integer of the previous row.

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
    var m = matrix.length;
    var n = matrix[0].length;
    var i = 0, j = 0;
    
    while( i < m && j < n){
        if( target > matrix[i][n-1-j]){
            i++;
        }else if( target < matrix[i][n-1-j]){
            j++;
        }else return true;
    }
    
    return false;
};

Search a 2D Matrix II
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

    Integers in each row are sorted in ascending from left to right.
    Integers in each column are sorted in ascending from top to bottom.

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
    var m = matrix.length;
    var n = matrix[0].length;
    var i = 0,j = 0;
    while( i < m && j < n ){
        if( target > matrix[i][n-j-1] ){
            i++;
        }else if( target < matrix[i][n-j-1]){
            j++;
        }else {
            return true;
        }
    }
    return false;
};

Linked List Cycle
Given a linked list, determine if it has a cycle in it.
思路： 双指针方法
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if( !head ) return false;
    var fastPoint = head;
    var slowPoint = head;
    
    do{
        if( fastPoint.next !== null && fastPoint.next.next !== null ) fastPoint = fastPoint.next.next;
        else return false;
        slowPoint = slowPoint.next;
    }while( fastPoint !== slowPoint );
    
    return true;
};

Linked List Cycle II

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Note: Do not modify the linked list.
思路： 
第一次相遇 慢指针走路程是快指针路程的一半，由此得出 L(head到循环开始) ＝ N*C（循环长度）- S（循环中相遇的节点）
要知道L 只需将快指针指向头节点 然后都一步一步走，再次相遇时就是L
因为走N*C-S 从位置上来看就是走剩下的路回到循环起点（同时他是等于L） 所以此时将一个指针回到起点，一步一步走就是然后相遇的时候就是cycle的起点了（L = C-S 。
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    if( !head ) return null;
    
    var slow = head, fast = head;
    
    do{
        if( fast.next !== null && fast.next.next !== null ){
            fast = fast.next.next;
        }else{
            return null;
        }
        slow =  slow.next;
    }while( fast !== slow);
    
    fast = head;
    while( fast !== slow ){
        fast = fast.next;
        slow = slow.next;
    }
    
    return fast;
};


Add two numbers
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    if( l1 === null && l2 === null ) return [];
    
    var res = new ListNode(0);
    var head = res;
    var carry = 0;
    
    while( l1 || l2){
        var num1 = (l1 === null) ? 0 : l1.val;
        var num2 = (l2 === null) ? 0 : l2.val;
        sum = num1 + num2 + carry;
        var newNode = new ListNode( sum % 10 );
        carry = Math.floor( sum / 10 );
        res.next = newNode;
        res = res.next;
        l1 = l1 === null ? null : l1.next;
        l2 = l2 === null ? null : l2.next;
    }
    
    if( carry ){
        res.next = new ListNode(carry);
        res = res.next;
    }
    
    res.next = null;
    
    return head.next;
};


Number of Digit One

Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

For example:
Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. 
思路：
每位计算1在其范围内出现的次数
如果该位为 0，1 则不能覆盖
否则全覆盖，用Math.floor(n/m) + 8 来判断
/**
 * @param {number} n
 * @return {number}
 */
var countDigitOne = function(n) {
    var ones = 0;
    for (var m = 1; m <= n; m *= 10)
        ones += Math.floor((Math.floor(n/m) + 8) / 10) * m + (Math.floor(n/m) % 10 == 1 ? n%m + 1 : 0);
    return ones;
};

Evaluate Reverse Polish Notation

Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:

  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6

/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
    var numStack = [], num1 = 0, num2 = 0;
    
    while( tokens.length ){
        var to = tokens.shift();
        if( /[0-9]/.test( parseInt(to) ) ){
            numStack.push(parseInt(to));
        }else {
            num1 = numStack.pop();
            num2 = numStack.pop();
            if( to === "+" ){
                numStack.push(num2 + num1);
            }else if( to === "-" ){
                numStack.push(num2 - num1);    
            }else if( to === "*"){
                numStack.push(num2 * num1);
            }else{
                if( (num2 / num1) < 0 ) numStack.push( Math.ceil( num2 / num1) );
                else numStack.push( Math.floor(num2 / num1) );
            }
        }
    }
    
    return numStack.pop();
};


Jump Game
思路：
当跳到位置i后，能达到的最大的点是i+A[i]。用greedy来解，记录一个当前能达到的最远距离maxIndex：

1. 能跳到位置i的条件：i<=maxIndex。
2. 一旦跳到i，则maxIndex = max(maxIndex, i+A[i])。
3. 能跳到最后一个位置n-1的条件是：maxIndex >= n-1
 Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false. 
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    var maxIndex = 0;
    for(var i = 0; i < nums.length; i++){
        if( i > maxIndex || nums.length-1 <= maxIndex ) break;
        maxIndex = Math.max(maxIndex, i+nums[i]);
    }
    
    return nums.length-1 <= maxIndex ? true : false;
};

Repeated DNA Sequences
 All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

For example,

Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].

思路：
先将字母转换为ascII： s.charCodeAt(i++) & 7 用7 是因为T转换后是7（111），所以也要移动3位
然后先收入9位，然后从第10位开始显示和mask(00000111111111111111111111111111),每个字母占三位，所以总共9个初始化位27
然后再是左移3位加入第十位然后开始用hashtable判断

/**
 * @param {string} s
 * @return {string[]}
 */
var findRepeatedDnaSequences = function(s) {
    var res = [];
    var hash = {};
    var mask = 0x07ffffff;
    var i = 0;
    var cur = 0 ;
    
    while( i < 9 ){
        cur = (cur << 3) | s.charCodeAt(i++) & 7;
    }
    
    for(; i < s.length; i++){
        cur = ((cur & mask) << 3) | s.charCodeAt(i) & 7;
        if( hash[cur] === undefined ){
            hash[cur] = 1;
        }else{
            if( hash[cur] === 1){
                res.push(s.substring(i-9,i+1));
            }
            hash[cur]++;
        }
    }
    return res;
};

Convert Sorted Array to Binary Search Tree

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    if( nums.length === 0 ) return nums;
    if( nums.length === 1 ) return new TreeNode(nums[0]);
    
    var mid = Math.floor( nums.length / 2 );
    var root = new TreeNode( nums[mid] );
    var left = nums.slice(0, mid);
    var right = nums.slice(mid+1);
    
    if( left.length ) root.left = sortedArrayToBST( left );
    if( right.length ) root.right = sortedArrayToBST( right );
    
    return root;
};


Convert Sorted List to Binary Search Tree
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
Subscribe to see which companies asked this question

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {TreeNode}
 */
var sortedListToBST = function(head) {
    if( head === null ) return null;
    if( head.next === null ) return new TreeNode( head.val );
    
    var slow = head, fast = head, hhead = new ListNode(0);
    hhead.next = head;
    while( fast.next !== null && fast.next.next !== null ){
        slow = slow.next;
        fast = fast.next.next;
    }
    
    var root = new TreeNode( slow.val );
    var right = slow.next;
    var leftPart = hhead;
    while( leftPart !== null && leftPart.next !== slow ){
        leftPart = leftPart.next;
    }
    
    leftPart.next = null;
    
    var left = hhead.next;
    root.left = sortedListToBST(left);
    root.right = sortedListToBST(right);
    
    return root;
};

Word Break

Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code". 

思路： 动态规划
label[i] 表示在s中到i为止，这段字符串可以在字典里面拼接出来
这里使用了set的has方法

/**
 * @param {string} s
 * @param {set<string>} wordDict
 *   Note: wordDict is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
    if(!wordDict.size) return false;
    var label = [];
    for( var i = 0; i < s.length+1; i++){
        label[i] = false;
    }
    
    label[0] = true;
    
    for( var j = 1; j <= s.length; j++){
        for( var k = 0; k < j; k++){
            var st = s.substring(k,j);
            if( label[k] && wordDict.has(st) ){
                label[j] = true;
            }
        }
    }
    
    return label[s.length];
};

generate parentheses
 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

"((()))", "(()())", "(())()", "()(())", "()()()" 
思路：
通过向string插入"("和")"直到两者的数量都为n，则一个combination构建完成。如何保证这个combination是well-formed？在插入过程中的任何时候：

1. 只要"("的数量没有超过n，都可以插入"("。
2. 而可以插入")"的前提则是当前的"("数量必须要多余当前的")"数量。
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    var allRes = [],unitRes =[];
    comb(n,0,0,unitRes,allRes);
    return allRes;
};

var comb = function(n,left,right,ur,ar){
    if( left === n && right === n){
        ar.push( ur.join("") );
        return;
    }
    
    if( left < n){
        ur.push("(");
        comb(n,left+1,right,ur,ar);
        ur.pop();
    }
    
    if( right < left ){
        ur.push(")");
        comb(n,left,right+1,ur,ar);
        ur.pop();
    }
}

combination:

/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    var res = [], unitRes = [];
    comb(n, k, unitRes, res, 1);
    return res;
};


var comb = function(n,k, unitRes, res,j){
   while( unitRes.length < k){
       if( j <= n){
           unitRes.push(j);
           comb(n,k,unitRes,res,++j);
       }else{
           unitRes.pop();
           return ;
       }
   }
   
   res.push(unitRes.slice());
   unitRes.pop();
}

comb sum I
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. 
For example, given candidate set 2,3,6,7 and target 7,
A solution set is:
[7]
[2, 2, 3]
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
  var results = [], result = [];
  candidates.sort(function(a,b){
      return a-b;
  });
  comb(candidates, target, results, result, 0);
  return results;
};

var comb = function(candidates, target, results, result, i){
    if( target === 0 ){
        results.push(result.slice());
        return;
    }
    
    for( var j = i ; j < candidates.length; j++ ){
        if( candidates[j] === candidates[j-1] && j > i ) continue;
        if( candidates[j] <= target){
            result.push( candidates[j] );
            comb(candidates, target-candidates[j], results, result, j);
            result.pop();
        }
    }
}

combination sum II
same as I but The solution set must not contain duplicate combinations.
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    var results = [], result = [];
    candidates.sort(function(a,b){
        return a-b;
    });
    
    comb(candidates, target, results, result, 0);
    return results;
};

var comb = function(c,t,rs,r,i){
    if( t === 0 ){
        rs.push(r.slice());
        return;
    }
    
    for( var j = i; j < c.length; j++){
        if( j > i && c[j-1] === c[j] ) continue;
        if( c[j] <= t){
            r.push(c[j]);
            comb(c,t-c[j],rs,r,j+1);
            r.pop();
        }
    }
}

combination sum III
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
    var results = [], result = [];
    comb(k, n, results, result, 1);
    return results;
};

var comb = function(k, n,rs,r,i){
    if( n === 0 && r.length === k ){
        rs.push(r.slice());
        return;
    }
    
    for( var j = i; j <= 9 ; j++){
        if( j <= n && r.length <= k ){
            r.push(j);
            comb(k,n-j,rs,r,j+1);
            r.pop();
        }
        
    }
}

Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.

For example,
123 -> "One Hundred Twenty Three"
12345 -> "Twelve Thousand Three Hundred Forty Five"
1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

/**
 * @param {number} num
 * @return {string}
 */
var numberToWords = function(num) {
    var unit = ["","Thousand","Million","Billion","Trillion","Pillion"];
    if( num === 0 ) return "Zero";
    
    var section = num;
    var flag = 0;
    var s = "";
    
    while( num ){
        section = section % 1000;
        if( section !== 0 ){ 
            s = unitConvert(section) + " " +unit[flag] + " " + s;
        }

        num = Math.floor(num/1000);
        section = num;
        flag++;
    }
    
    return s.trim();
};

var unitConvert = function(unitSection){
    var unitS = "";
    var numberTable = ["","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"];
    var numberTable2 = ["","","Twenty","Thirty","Forty","Fifty","Sixty","Seventy","Eighty","Ninety"];
    
    var one = unitSection % 10;
    var two = Math.floor(unitSection / 10) % 10;
    var three = Math.floor(unitSection / 100);
    
    if( (two * 10 + one) < 20 ) unitS = numberTable[ two * 10 + one ];
    else {
        unitS = numberTable2[two] + " " + numberTable[one] + unitS;
    }
    
    if( three ) unitS = numberTable[three]+ " " + "Hundred" + " " + unitS;
    return unitS.trim();
};

Largest Number My Submissions Question
Given a list of non negative integers, arrange them such that they form the largest number.

For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.

/**
 * @param {number[]} nums
 * @return {string}
 */
var largestNumber = function(nums) {
  nums.sort(function(a,b){
      return  (  parseInt(b+""+a) - parseInt( a+""+b) );
  });
  
  if( nums[0] === 0 ) return "0";
  return nums.join("");

};


Find Minimum in Rotated Sorted Array My Submissions Question
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.


/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    var mid = Math.floor( nums.length / 2 ) ;
    var start = 0, end = nums.length - 1;
    while( start < end){
        if( nums[mid] > nums[end] ){
            start = mid + 1;
        }else{
            end = mid;
        }
        
        mid = Math.floor( ( start + end ) / 2 );
    }
    
    return nums[start];
};

Rotate List My Submissions Question
Given a list, rotate the list to the right by k places, where k is non-negative.

For example:
Given 1->2->3->4->5->NULL and k = 2,
return 4->5->1->2->3->NULL.
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var rotateRight = function(head, k) {
    if( head === null ) return [];
    
    var fakeHead = new ListNode(0);
    var start = head,end = head;
    var lenHead = head,len = 0;
    
    while( lenHead ){
        lenHead = lenHead.next;
        len++;
    }
    
    k = k % len;
    
    if( k === 0 ) return head;
    
    while( k-- ){
        end = end.next;
    }
    
    while( end.next ){
        start = start.next;
        end = end.next;
    }
    
    var newHead = start.next;
    start.next =  null;
    end.next = head;
    
    fakeHead.next = newHead;
    
    return fakeHead.next;
    
};


Reverse Linked List II My Submissions Question
Reverse a linked list from position m to n. Do it in-place and in one-pass.

For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
var reverseBetween = function(head, m, n) {
    if( m<1 || m>=n || !head ) return head;
    var fakeHead = new ListNode(0);
    fakeHead.next = head;
    head = fakeHead;
    var i = 0;
    while( i < m - 1 ){
        head = head.next;
        i++;
    }
    
    var pre = head.next, cur = pre.next;
    for( var j = 0; j < n-m; j++){
        var tmp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = tmp; 
    }
    
    head.next.next = cur;
    head.next = pre;
    return fakeHead.next;
};

Triangle My Submissions Question
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
    if( !triangle.length ) return 0;
    var n = triangle.length;
    var path = [];
    
    for( var i = n - 1; i >= 0; i-- ){
        var m = triangle[i].length;
        for( var j = 0; j < m; j++){
            if( i === n - 1 ){
                path[j] = triangle[i][j];
                continue;
            }
            
            path[j] = triangle[i][j] + Math.min(path[j],path[j+1]);
        }
    }
    
    return path[0];
    
};

134. Gas Station My Submissions Question

从0开始计算sum(gas[i] - cost[i])，当遇到i1使sum<0时，说明从0出发无法到达i1. 0不是起始点。而由于从0出发已经到达了1 ~ i1-1。1 ~ i1-1一定不是正确的起始点。此时i1为起始点的候选。

There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
    var net = 0, sum = 0, start = 0;
    for( var i = 0; i < gas.length; i++){
        net += gas[i] - cost[i];
        sum += gas[i] - cost[i];
        if( sum < 0 ){
            sum = 0;
            start = i+1;
        }
    }
    if( net < 0 ) return -1;
    return start+1 ;
};


113. Path Sum II My Submissions Question
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

For example:
Given the below binary tree and sum = 22,
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
    if( root === null ) return [];
    var accu = 0, res = [], tmp = [];
    
    traverse(root, sum, accu, res, tmp);
    
    return res;
};

var traverse = function(node, sum, accu, res, tmp){
    if( !node ) return;
    
    accu += node.val;
    tmp.push(node.val);
    
    if( node.left === null && node.right === null  ){
        if( accu === sum ) res.push(tmp.slice());
    }
    
    if( node.left !== null) traverse(node.left, sum, accu, res,tmp);
    if( node.right !== null ) traverse(node.right, sum, accu, res,tmp);
    
    tmp.pop();
}

71. Simplify Path My Submissions Question
Given an absolute path for a file (Unix-style), simplify it.

For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    var stack = [], res = "";
    var pathArray = path.split("/");
    for( var i = 0; i < pathArray.length; i++){
        if( pathArray[i] === ".."){
            if( stack.length ) stack.pop();
            else continue;
        }else if( pathArray[i] === "." || pathArray[i] === "" ) continue;
        else stack.push(pathArray[i]);
    }
    
    return "/"+stack.join('/');
};

Subsets I
Given a set of distinct integers, nums, return all possible subsets.
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    var allsets = [[]], sets = [];
    nums.sort(function(a,b){ return a-b });
    findAllsets(nums, 0, sets, allsets);
    return allsets;
};

var findAllsets = function(nums,s,sets, allsets){
    for(var i = s; i < nums.length; i++ ){
        sets.push(nums[i]);
        allsets.push(sets.slice());
        findAllsets(nums,i+1, sets, allsets);
        sets.pop();
    }
}

Subsets II My Submissions Question
Given a collection of integers that might contain duplicates, nums, return all possible subsets.
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
    var allsets = [[]], sets = [];
    nums.sort(function(a,b){ return a-b });
    findAllsets(nums, 0, sets, allsets);
    return allsets;
};

var findAllsets = function(nums,s,sets, allsets){
    for(var i = s; i < nums.length; i++ ){
        if( i > s && nums[i] === nums[i-1] ) continue;
        sets.push(nums[i]);
        allsets.push(sets.slice());
        findAllsets(nums,i+1, sets, allsets);
        sets.pop();
    }
}

Group Anagrams My Submissions Question
思路： 创建一个hash， 对数组先排序，然后对每个字符串进行排序处理对比hash表，添加到相应位置，最后输出到返回数组中
Given an array of strings, group anagrams together.
For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
Return:

[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    var hash = {};
    var res = [];
    strs.sort();
    
    for(var i = 0; i < strs.length; i++){
        var key = strs[i].split('').sort().join('');
        if( hash[key] === undefined ) {
            hash[key] = [];
        }
        hash[key].push(strs[i]);
    }
    
    for( var j in hash){
        res.push(hash[j]);
    }
    
    return res;
};

Partition List
思路： 设定两个链表，链表操作： 设定一个dummyhead用于保存初始头。
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function(head, x) {
    if( !head ) return [];
    var p = new ListNode(0);
    var pHead = p;
    var q = new ListNode(0);
    var qHead = q;
    
    while( head ){
        if( head.val < x ){
            p.next = head;
            p = p.next;
        }else{
            q.next = head;
            q = q.next;
        }
        head = head.next;
    }
    
    p.next = qHead.next;
    q.next = null;
    return pHead.next;
};

-----------careercup---------------------
function sort(a,b){
  for(var i  = 0; i < b.length;){
    if( b[i] === i ) i++;
    else{
      var tmp = a[i];
      a[i] = a[b[i]];
      a[b[i]] = tmp ;
    
      var nTmp = b[i];
      b[i] = b[b[i]];
      b[nTmp] = nTmp;
      
    }
  }
  
  return a;
  
}

var a = ["C","D","E","F","G"];
var b = [3,0,4,1,2];

sort(a,b);
a is [d,f,g,c,e]